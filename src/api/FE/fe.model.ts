//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class FEClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : 'https://www.dnd5eapi.co';
  }

  /**
   * Get all resource URLs.
   * @return OK
   */
  api(): Promise<{ [key: string]: string }> {
    let url_ = this.baseUrl + '/api';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processApi(_response);
    });
  }

  protected processApi(response: Response): Promise<{ [key: string]: string }> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as {
                [key: string]: string;
              });
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<{ [key: string]: string }>(null as any);
  }

  /**
   * Get list of all available resources for an endpoint.
   * @return OK
   */
  api2(endpoint: Endpoint): Promise<APIReferenceList> {
    let url_ = this.baseUrl + '/api/{endpoint}';
    if (endpoint === undefined || endpoint === null)
      throw new Error("The parameter 'endpoint' must be defined.");
    url_ = url_.replace('{endpoint}', encodeURIComponent('' + endpoint));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processApi2(_response);
    });
  }

  protected processApi2(response: Response): Promise<APIReferenceList> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as APIReferenceList);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<APIReferenceList>(null as any);
  }

  /**
   * Get an ability score by index.
   * @param index The `index` of the ability score to get.
   * @return OK
   */
  abilityScores(index: Index): Promise<AbilityScore> {
    let url_ = this.baseUrl + '/api/ability-scores/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAbilityScores(_response);
    });
  }

  protected processAbilityScores(response: Response): Promise<AbilityScore> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as AbilityScore);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<AbilityScore>(null as any);
  }

  /**
   * Get an alignment by index.
   * @param index The `index` of the alignment to get.
   * @return OK
   */
  alignments(index: Index2): Promise<Alignment> {
    let url_ = this.baseUrl + '/api/alignments/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAlignments(_response);
    });
  }

  protected processAlignments(response: Response): Promise<Alignment> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as Alignment);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Alignment>(null as any);
  }

  /**
   * Get a background by index.
   * @param index The `index` of the background to get.
   * @return OK
   */
  backgrounds(index: Index3): Promise<Background> {
    let url_ = this.baseUrl + '/api/backgrounds/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processBackgrounds(_response);
    });
  }

  protected processBackgrounds(response: Response): Promise<Background> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as Background);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Background>(null as any);
  }

  /**
   * Get a class by index.
   * @param index The `index` of the class to get.
   * @return OK
   */
  classes(index: Index4): Promise<Class> {
    let url_ = this.baseUrl + '/api/classes/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processClasses(_response);
    });
  }

  protected processClasses(response: Response): Promise<Class> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as Class);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Class>(null as any);
  }

  /**
   * Get subclasses available for a class.
   * @param index The `index` of the class to get.
   * @return OK
   */
  subclasses(index: Index4): Promise<APIReferenceList> {
    let url_ = this.baseUrl + '/api/classes/{index}/subclasses';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSubclasses(_response);
    });
  }

  protected processSubclasses(response: Response): Promise<APIReferenceList> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as APIReferenceList);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<APIReferenceList>(null as any);
  }

  /**
   * Get spells available for a class.
   * @param index The `index` of the class to get.
   * @return OK
   */
  spells(index: Index4): Promise<APIReferenceList> {
    let url_ = this.baseUrl + '/api/classes/{index}/spells';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSpells(_response);
    });
  }

  protected processSpells(response: Response): Promise<APIReferenceList> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as APIReferenceList);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<APIReferenceList>(null as any);
  }

  /**
   * Get spellcasting info for a class.
   * @param index The `index` of the class to get.
   * @return OK
   */
  spellcasting(index: Index4): Promise<Spellcasting> {
    let url_ = this.baseUrl + '/api/classes/{index}/spellcasting';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSpellcasting(_response);
    });
  }

  protected processSpellcasting(response: Response): Promise<Spellcasting> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as Spellcasting);
        return result200;
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as ErrorResponse);
        return throwException(
          'Not found.',
          status,
          _responseText,
          _headers,
          result404,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Spellcasting>(null as any);
  }

  /**
   * Get features available for a class.
   * @param index The `index` of the class to get.
   * @return List of features for the class.
   */
  features(index: Index4): Promise<APIReferenceList> {
    let url_ = this.baseUrl + '/api/classes/{index}/features';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFeatures(_response);
    });
  }

  protected processFeatures(response: Response): Promise<APIReferenceList> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as APIReferenceList);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<APIReferenceList>(null as any);
  }

  /**
   * Get proficiencies available for a class.
   * @param index The `index` of the class to get.
   * @return List of proficiencies for the class.
   */
  proficiencies(index: Index4): Promise<APIReferenceList> {
    let url_ = this.baseUrl + '/api/classes/{index}/proficiencies';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processProficiencies(_response);
    });
  }

  protected processProficiencies(
    response: Response,
  ): Promise<APIReferenceList> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as APIReferenceList);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<APIReferenceList>(null as any);
  }

  /**
   * Get multiclassing resource for a class.
   * @param index The `index` of the class to get.
   * @return OK
   */
  multiClassing(index: Index4): Promise<Multiclassing> {
    let url_ = this.baseUrl + '/api/classes/{index}/multi-classing';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processMultiClassing(_response);
    });
  }

  protected processMultiClassing(response: Response): Promise<Multiclassing> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as Multiclassing);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Multiclassing>(null as any);
  }

  /**
   * Get all level resources for a class.
   * @param index The `index` of the class to get.
   * @param subclass (optional) Adds subclasses for class to the response
   * @return OK
   */
  levelsAll(
    index: Index4,
    subclass?: string | undefined,
  ): Promise<ClassLevel[]> {
    let url_ = this.baseUrl + '/api/classes/{index}/levels?';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    if (subclass === null)
      throw new Error("The parameter 'subclass' cannot be null.");
    else if (subclass !== undefined)
      url_ += 'subclass=' + encodeURIComponent('' + subclass) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLevelsAll(_response);
    });
  }

  protected processLevelsAll(response: Response): Promise<ClassLevel[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as ClassLevel[]);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<ClassLevel[]>(null as any);
  }

  /**
   * Get level resource for a class and level.
   * @param index The `index` of the class to get.
   * @return OK
   */
  levels(index: Index4, class_level: number): Promise<ClassLevel> {
    let url_ = this.baseUrl + '/api/classes/{index}/levels/{class_level}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    if (class_level === undefined || class_level === null)
      throw new Error("The parameter 'class_level' must be defined.");
    url_ = url_.replace('{class_level}', encodeURIComponent('' + class_level));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLevels(_response);
    });
  }

  protected processLevels(response: Response): Promise<ClassLevel> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ClassLevel);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<ClassLevel>(null as any);
  }

  /**
   * Get features available to a class at the requested level.
   * @param index The `index` of the class to get.
   * @return OK
   */
  features2(index: Index4, class_level: number): Promise<APIReferenceList> {
    let url_ =
      this.baseUrl + '/api/classes/{index}/levels/{class_level}/features';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    if (class_level === undefined || class_level === null)
      throw new Error("The parameter 'class_level' must be defined.");
    url_ = url_.replace('{class_level}', encodeURIComponent('' + class_level));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFeatures2(_response);
    });
  }

  protected processFeatures2(response: Response): Promise<APIReferenceList> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as APIReferenceList);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<APIReferenceList>(null as any);
  }

  /**
   * Get spells of the requested level available to the class.
   * @param index The `index` of the class to get.
   * @return OK
   */
  spells2(index: Index4, spell_level: number): Promise<APIReferenceList> {
    let url_ =
      this.baseUrl + '/api/classes/{index}/levels/{spell_level}/spells';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    if (spell_level === undefined || spell_level === null)
      throw new Error("The parameter 'spell_level' must be defined.");
    url_ = url_.replace('{spell_level}', encodeURIComponent('' + spell_level));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSpells2(_response);
    });
  }

  protected processSpells2(response: Response): Promise<APIReferenceList> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as APIReferenceList);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<APIReferenceList>(null as any);
  }

  /**
   * Get a condition by index.
   * @param index The `index` of the condition to get.
   * @return OK
   */
  conditions(index: Index5): Promise<Condition> {
    let url_ = this.baseUrl + '/api/conditions/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConditions(_response);
    });
  }

  protected processConditions(response: Response): Promise<Condition> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as Condition);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Condition>(null as any);
  }

  /**
   * Get a damage type by index.
   * @param index The `index` of the damage type to get.
   * @return OK
   */
  damageTypes(index: Index6): Promise<DamageType> {
    let url_ = this.baseUrl + '/api/damage-types/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDamageTypes(_response);
    });
  }

  protected processDamageTypes(response: Response): Promise<DamageType> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DamageType);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<DamageType>(null as any);
  }

  /**
   * Get an equipment item by index.
   * @param index The `index` of the equipment to get.

  Available values can be found in the [`ResourceList`](#get-/api/-endpoint-) for `equipment`.
   * @return OK
   */
  equipment(index: string): Promise<Equipment> {
    let url_ = this.baseUrl + '/api/equipment/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processEquipment(_response);
    });
  }

  protected processEquipment(response: Response): Promise<Equipment> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as Equipment);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Equipment>(null as any);
  }

  /**
   * Get an equipment category by index.
   * @param index The `index` of the equipment category score to get.

  Available values can be found in the resource list for this endpoint.
   * @return OK
   */
  equipmentCategories(index: string): Promise<EquipmentCategory> {
    let url_ = this.baseUrl + '/api/equipment-categories/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processEquipmentCategories(_response);
    });
  }

  protected processEquipmentCategories(
    response: Response,
  ): Promise<EquipmentCategory> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as EquipmentCategory);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<EquipmentCategory>(null as any);
  }

  /**
   * Get a feat by index.
   * @param index The `index` of the feat to get.
   * @return OK
   */
  feats(index: Index7): Promise<Feat> {
    let url_ = this.baseUrl + '/api/feats/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFeats(_response);
    });
  }

  protected processFeats(response: Response): Promise<Feat> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as Feat);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Feat>(null as any);
  }

  /**
   * Get a feature by index.
   * @param index The `index` of the feature to get.

  Available values can be found in the [`ResourceList`](#get-/api/-endpoint-) for `features`.
   * @return OK
   */
  features3(index: string): Promise<Feature> {
    let url_ = this.baseUrl + '/api/features/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFeatures3(_response);
    });
  }

  protected processFeatures3(response: Response): Promise<Feature> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as Feature);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Feature>(null as any);
  }

  /**
   * Get a language by index.
   * @param index The `index` of the language to get.
   * @return OK
   */
  languages(index: Index8): Promise<Language> {
    let url_ = this.baseUrl + '/api/languages/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLanguages(_response);
    });
  }

  protected processLanguages(response: Response): Promise<Language> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as Language);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Language>(null as any);
  }

  /**
   * Get a magic item by index.
   * @param index The `index` of the magic item to get.

  Available values can be found in the resource list for this endpoint.
   * @return OK
   */
  magicItems(index: string): Promise<MagicItem> {
    let url_ = this.baseUrl + '/api/magic-items/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processMagicItems(_response);
    });
  }

  protected processMagicItems(response: Response): Promise<MagicItem> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as MagicItem);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<MagicItem>(null as any);
  }

  /**
   * Get a magic school by index.
   * @param index The `index` of the magic school to get.
   * @return OK
   */
  magicSchools(index: Index9): Promise<MagicSchool> {
    let url_ = this.baseUrl + '/api/magic-schools/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processMagicSchools(_response);
    });
  }

  protected processMagicSchools(response: Response): Promise<MagicSchool> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as MagicSchool);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<MagicSchool>(null as any);
  }

  /**
   * Get list of monsters with optional filtering
   * @param challenge_rating (optional) The challenge rating or ratings to filter on.
   * @return OK
   */
  monsters(challenge_rating?: number[] | undefined): Promise<APIReferenceList> {
    let url_ = this.baseUrl + '/api/monsters?';
    if (challenge_rating === null)
      throw new Error("The parameter 'challenge_rating' cannot be null.");
    else if (challenge_rating !== undefined)
      challenge_rating &&
        challenge_rating.forEach((item) => {
          url_ += 'challenge_rating=' + encodeURIComponent('' + item) + '&';
        });
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processMonsters(_response);
    });
  }

  protected processMonsters(response: Response): Promise<APIReferenceList> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as APIReferenceList);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<APIReferenceList>(null as any);
  }

  /**
   * Get monster by index.
   * @param index The `index` of the `Monster` to get.
   * @return OK
   */
  monsters2(index: string): Promise<Required<Monster>> {
    let url_ = this.baseUrl + '/api/monsters/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processMonsters2(_response);
    });
  }

  protected processMonsters2(response: Response): Promise<Required<Monster>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as Monster);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Required<Monster>>(null as any);
  }

  /**
   * Get a proficiency by index.
   * @param index The `index` of the proficiency to get.

  Available values can be found in the [`ResourceList`](#get-/api/-endpoint-) for `proficiencies`.
   * @return OK
   */
  proficiencies2(index: string): Promise<Proficiency> {
    let url_ = this.baseUrl + '/api/proficiencies/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processProficiencies2(_response);
    });
  }

  protected processProficiencies2(response: Response): Promise<Proficiency> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as Proficiency);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Proficiency>(null as any);
  }

  /**
   * Get a race by index.
   * @param index The `index` of the race to get.
   * @return OK
   */
  races(index: Index10): Promise<Race> {
    let url_ = this.baseUrl + '/api/races/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRaces(_response);
    });
  }

  protected processRaces(response: Response): Promise<Race> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as Race);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Race>(null as any);
  }

  /**
   * Get subraces available for a race.
   * @param index The `index` of the race to get.
   * @return List of subraces for the race.
   */
  subraces(index: Index10): Promise<APIReferenceList> {
    let url_ = this.baseUrl + '/api/races/{index}/subraces';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSubraces(_response);
    });
  }

  protected processSubraces(response: Response): Promise<APIReferenceList> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as APIReferenceList);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<APIReferenceList>(null as any);
  }

  /**
   * Get proficiencies available for a race.
   * @param index The `index` of the race to get.
   * @return List of proficiencies for the race.
   */
  proficiencies3(index: Index10): Promise<APIReferenceList> {
    let url_ = this.baseUrl + '/api/races/{index}/proficiencies';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processProficiencies3(_response);
    });
  }

  protected processProficiencies3(
    response: Response,
  ): Promise<APIReferenceList> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as APIReferenceList);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<APIReferenceList>(null as any);
  }

  /**
   * Get traits available for a race.
   * @param index The `index` of the race to get.
   * @return List of traits for the race.
   */
  traits(index: Index10): Promise<APIReferenceList> {
    let url_ = this.baseUrl + '/api/races/{index}/traits';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processTraits(_response);
    });
  }

  protected processTraits(response: Response): Promise<APIReferenceList> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as APIReferenceList);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<APIReferenceList>(null as any);
  }

  /**
   * Get a rule section by index.
   * @param index The `index` of the rule section to get.
   * @return OK
   */
  ruleSections(index: Index11): Promise<RuleSection> {
    let url_ = this.baseUrl + '/api/rule-sections/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRuleSections(_response);
    });
  }

  protected processRuleSections(response: Response): Promise<RuleSection> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as RuleSection);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<RuleSection>(null as any);
  }

  /**
   * Get a rule by index.
   * @param index The `index` of the rule to get.
   * @return OK
   */
  rules(index: Index12): Promise<Rule> {
    let url_ = this.baseUrl + '/api/rules/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRules(_response);
    });
  }

  protected processRules(response: Response): Promise<Rule> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as Rule);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Rule>(null as any);
  }

  /**
   * Get a skill by index.
   * @param index The `index` of the skill to get.
   * @return OK
   */
  skills(index: Index13): Promise<Skill> {
    let url_ = this.baseUrl + '/api/skills/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSkills(_response);
    });
  }

  protected processSkills(response: Response): Promise<Skill> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as Skill);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Skill>(null as any);
  }

  /**
   * Get list of spells with optional filtering.
   * @param level (optional) The level or levels to filter on.
   * @param school (optional) The magic school or schools to filter on.
   * @return OK
   */
  spells3(
    level?: number[] | undefined,
    school?: string[] | undefined,
  ): Promise<APIReferenceList> {
    let url_ = this.baseUrl + '/api/spells?';
    if (level === null)
      throw new Error("The parameter 'level' cannot be null.");
    else if (level !== undefined)
      level &&
        level.forEach((item) => {
          url_ += 'level=' + encodeURIComponent('' + item) + '&';
        });
    if (school === null)
      throw new Error("The parameter 'school' cannot be null.");
    else if (school !== undefined)
      school &&
        school.forEach((item) => {
          url_ += 'school=' + encodeURIComponent('' + item) + '&';
        });
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSpells3(_response);
    });
  }

  protected processSpells3(response: Response): Promise<APIReferenceList> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as APIReferenceList);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<APIReferenceList>(null as any);
  }

  /**
   * Get a spell by index.
   * @param index The `index` of the `Spell` to get.

  Available values can be found in the [`ResourceList`](#get-/api/-endpoint-) for `spells`.
   * @return OK
   */
  spells4(index: string): Promise<Spell> {
    let url_ = this.baseUrl + '/api/spells/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSpells4(_response);
    });
  }

  protected processSpells4(response: Response): Promise<Spell> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as Spell);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Spell>(null as any);
  }

  /**
   * Get a subclass by index.
   * @param index The `index` of the subclass to get.
   * @return OK
   */
  subclasses2(index: Index14): Promise<Subclass> {
    let url_ = this.baseUrl + '/api/subclasses/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSubclasses2(_response);
    });
  }

  protected processSubclasses2(response: Response): Promise<Subclass> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as Subclass);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Subclass>(null as any);
  }

  /**
   * Get features available for a subclass.
   * @param index The `index` of the subclass to get.
   * @return List of features for the subclass.
   */
  features4(index: Index14): Promise<APIReferenceList> {
    let url_ = this.baseUrl + '/api/subclasses/{index}/features';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFeatures4(_response);
    });
  }

  protected processFeatures4(response: Response): Promise<APIReferenceList> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as APIReferenceList);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<APIReferenceList>(null as any);
  }

  /**
   * Get all level resources for a subclass.
   * @param index The `index` of the subclass to get.
   * @return List of level resource for the subclass.
   */
  levelsAll2(index: Index14): Promise<SubclassLevelResource[]> {
    let url_ = this.baseUrl + '/api/subclasses/{index}/levels';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLevelsAll2(_response);
    });
  }

  protected processLevelsAll2(
    response: Response,
  ): Promise<SubclassLevelResource[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as SubclassLevelResource[]);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<SubclassLevelResource[]>(null as any);
  }

  /**
   * Get level resources for a subclass and level.
   * @param index The `index` of the subclass to get.
   * @return Level resource for the subclass and level.
   */
  levels2(index: Index14, subclass_level: number): Promise<SubclassLevel> {
    let url_ = this.baseUrl + '/api/subclasses/{index}/levels/{subclass_level}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    if (subclass_level === undefined || subclass_level === null)
      throw new Error("The parameter 'subclass_level' must be defined.");
    url_ = url_.replace(
      '{subclass_level}',
      encodeURIComponent('' + subclass_level),
    );
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLevels2(_response);
    });
  }

  protected processLevels2(response: Response): Promise<SubclassLevel> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as SubclassLevel);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<SubclassLevel>(null as any);
  }

  /**
   * Get features of the requested spell level available to the class.
   * @param index The `index` of the subclass to get.
   * @return List of features for the subclass and level.
   */
  features5(index: Index14, subclass_level: number): Promise<APIReferenceList> {
    let url_ =
      this.baseUrl + '/api/subclasses/{index}/levels/{subclass_level}/features';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    if (subclass_level === undefined || subclass_level === null)
      throw new Error("The parameter 'subclass_level' must be defined.");
    url_ = url_.replace(
      '{subclass_level}',
      encodeURIComponent('' + subclass_level),
    );
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFeatures5(_response);
    });
  }

  protected processFeatures5(response: Response): Promise<APIReferenceList> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as APIReferenceList);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<APIReferenceList>(null as any);
  }

  /**
   * Get a subrace by index.
   * @param index The `index` of the subrace to get.
   * @return OK
   */
  subraces2(index: Index15): Promise<Subrace> {
    let url_ = this.baseUrl + '/api/subraces/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSubraces2(_response);
    });
  }

  protected processSubraces2(response: Response): Promise<Subrace> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as Subrace);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Subrace>(null as any);
  }

  /**
   * Get proficiences available for a subrace.
   * @param index The `index` of the subrace to get.
   * @return List of proficiences for the subrace.
   */
  proficiencies4(index: Index15): Promise<APIReferenceList> {
    let url_ = this.baseUrl + '/api/subraces/{index}/proficiencies';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processProficiencies4(_response);
    });
  }

  protected processProficiencies4(
    response: Response,
  ): Promise<APIReferenceList> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as APIReferenceList);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<APIReferenceList>(null as any);
  }

  /**
   * Get traits available for a subrace.
   * @param index The `index` of the subrace to get.
   * @return List of traits for the subrace.
   */
  traits2(index: Index15): Promise<APIReferenceList> {
    let url_ = this.baseUrl + '/api/subraces/{index}/traits';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processTraits2(_response);
    });
  }

  protected processTraits2(response: Response): Promise<APIReferenceList> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as APIReferenceList);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<APIReferenceList>(null as any);
  }

  /**
   * Get a trait by index.
   * @param index The `index` of the `Trait` to get.
   * @return OK
   */
  traits3(index: Index16): Promise<Trait> {
    let url_ = this.baseUrl + '/api/traits/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processTraits3(_response);
    });
  }

  protected processTraits3(response: Response): Promise<Trait> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as Trait);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Trait>(null as any);
  }

  /**
   * Get a weapon property by index.
   * @param index The `index` of the weapon property to get.
   * @return OK
   */
  weaponProperties(index: Index17): Promise<WeaponProperty> {
    let url_ = this.baseUrl + '/api/weapon-properties/{index}';
    if (index === undefined || index === null)
      throw new Error("The parameter 'index' must be defined.");
    url_ = url_.replace('{index}', encodeURIComponent('' + index));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processWeaponProperties(_response);
    });
  }

  protected processWeaponProperties(
    response: Response,
  ): Promise<WeaponProperty> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver,
              ) as WeaponProperty);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<WeaponProperty>(null as any);
  }
}

/** `APIReference` */
export interface APIReference {
  /** Resource index for shorthand searching. */
  index?: string;
  /** Name of the referenced resource. */
  name?: string;
  /** URL of the referenced resource. */
  url?: string;

  [key: string]: any;
}

/** `APIReferenceList` */
export interface APIReferenceList {
  /** Total number of resources available. */
  count?: number;
  results?: APIReference[];

  [key: string]: any;
}

/** `Damage` */
export interface Damage {
  damage_dice?: string;
  damage_type?: APIReference;

  [key: string]: any;
}

/** `Choice` */
export interface Choice {
  /** Description of the choice to be made. */
  desc?: string;
  /** Number of items to pick from the list. */
  choose?: number;
  /** Type of the resources to choose from. */
  type?: string;
  from?: Option;

  [key: string]: any;
}

export interface AreaOfEffect {
  size?: number;
  type?: AreaOfEffectType;

  [key: string]: any;
}

/** `Prerequisite` */
export interface Prerequisite {
  ability_score?: APIReference;
  /** Minimum score to meet the prerequisite. */
  minimum_score?: number;

  [key: string]: any;
}

export interface ResourceDescription {
  /** Description of the resource. */
  desc?: string[];

  [key: string]: any;
}

/** `AbilityScore` */
export interface AbilityScore extends APIReference {
  /** Description of the resource. */
  desc?: string[];
  /** Full name of the ability score. */
  full_name?: string;
  /** List of skills that use this ability score. */
  skills?: APIReference[];

  [key: string]: any;
}

/** `Alignment` */
export interface Alignment extends APIReference {
  /** Brief description of the resource. */
  desc?: string;
  /** Abbreviation/initials/acronym for the alignment. */
  abbreviation?: string;

  [key: string]: any;
}

/** `Class` */
export interface Class extends APIReference {
  /** Hit die of the class. (ex: 12 == 1d12). */
  hit_die?: number;
  /** URL of the level resource for the class. */
  class_levels?: string;
  multi_classing?: Multiclassing;
  spellcasting?: Spellcasting;
  /** URL of the spell resource list for the class. */
  spells?: string;
  /** List of equipment and their quantities all players of the class start with. */
  starting_equipment?: Starting_equipment[];
  /** List of choices of starting equipment. */
  starting_equipment_options?: Choice[];
  /** List of choices of starting proficiencies. */
  proficiency_choices?: Choice[];
  /** List of starting proficiencies for all new characters of this class. */
  proficiencies?: APIReference[];
  /** Saving throws the class is proficient in. */
  saving_throws?: APIReference[];
  /** List of all possible subclasses this class can specialize in. */
  subclasses?: APIReference[];

  [key: string]: any;
}

/** `Multiclassing` */
export interface Multiclassing {
  /** List of prerequisites that must be met. */
  prerequisites?: Prerequisite[];
  /** List of choices of prerequisites to meet for. */
  prerequisite_options?: Choice[];
  /** List of proficiencies available when multiclassing. */
  proficiencies?: APIReference[];
  /** List of choices of proficiencies that are given when multiclassing. */
  proficiency_choices?: Choice[];

  [key: string]: any;
}

/** `Spellcasting` */
export interface Spellcasting {
  /** Level at which the class can start using its spellcasting abilities. */
  level?: number;
  /** Descriptions of the class' ability to cast spells. */
  info?: Info[];
  /** Reference to the `AbilityScore` used for spellcasting by the class. */
  spellcasting_ability?: APIReference;

  [key: string]: any;
}

/** `Gear` */
export interface Gear extends APIReference {
  /** Description of the resource. */
  desc?: string[];
  equipment_category?: APIReference;
  gear_category?: APIReference;
  cost?: Cost;
  /** How much the equipment weighs. */
  weight?: number;

  [key: string]: any;
}

/** `EquipmentPack` */
export interface EquipmentPack extends APIReference {
  /** Description of the resource. */
  desc?: string[];
  equipment_category?: APIReference;
  gear_category?: APIReference;
  cost?: Cost;
  /** The list of adventuring gear in the pack. */
  contents?: APIReference[];

  [key: string]: any;
}

/** `EquipmentCategory` */
export interface EquipmentCategory extends APIReference {
  /** A list of the equipment that falls into this category. */
  equipment?: APIReference[];

  [key: string]: any;
}

/** `Equipment` */
export interface Equipment {
  [key: string]: any;
}

/** `Cost` */
export interface Cost {
  /** Numerical amount of coins. */
  quantity?: number;
  /** Unit of coinage. */
  unit?: string;

  [key: string]: any;
}

/** `Weapon` */
export interface Weapon extends APIReference {
  /** Description of the resource. */
  desc?: string[];
  equipment_category?: APIReference;
  /** The category of weapon this falls into. */
  weapon_category?: string;
  /** Whether this is a Melee or Ranged weapon. */
  weapon_range?: string;
  /** A combination of weapon_category and weapon_range. */
  category_range?: string;
  range?: Range;
  damage?: Damage;
  two_handed_damage?: Damage;
  /** A list of the properties this weapon has. */
  properties?: APIReference[];
  cost?: Cost;
  /** How much the equipment weighs. */
  weight?: number;

  [key: string]: any;
}

/** `Armor` */
export interface Armor extends APIReference {
  /** Description of the resource. */
  desc?: string[];
  equipment_category?: APIReference;
  /** The category of armor this falls into. */
  armor_category?: string;
  /** Details on how to calculate armor class. */
  armor_class?: { [key: string]: string };
  /** Minimum STR required to use this armor. */
  str_minimum?: number;
  /** Whether the armor gives disadvantage for Stealth. */
  stealth_disadvantage?: boolean;
  cost?: Cost;
  /** How much the equipment weighs. */
  weight?: number;

  [key: string]: any;
}

/** `MagicItem` */
export interface MagicItem extends APIReference {
  /** Description of the resource. */
  desc?: string[];
  equipment_category?: APIReference;
  rarity?: Rarity;
  variants?: APIReference[];
  /** Whether this is a variant or not */
  variant?: boolean;

  [key: string]: any;
}

/** `DamageType` */
export interface DamageType extends APIReference {
  /** Description of the resource. */
  desc?: string[];

  [key: string]: any;
}

/** 'Spell Damage' */
export interface DamageAtCharacterLevel {
  damage_at_character_level?: any;
  damage_type?: APIReference;

  [key: string]: any;
}

/** 'Spell Damage' */
export interface DamageAtSlotLevel {
  damage_at_slot_level?: any;
  damage_type?: APIReference;

  [key: string]: any;
}

/** `Condition` */
export interface Condition extends APIReference {
  /** Description of the resource. */
  desc?: string[];

  [key: string]: any;
}

/** `MagicSchool` */
export interface MagicSchool extends APIReference {
  /** Brief description of the resource. */
  desc?: string;

  [key: string]: any;
}

/** `Skill` */
export interface Skill extends APIReference {
  /** Description of the resource. */
  desc?: string[];
  ability_score?: APIReference;

  [key: string]: any;
}

/** `Proficiency` */
export interface Proficiency extends APIReference {
  /** The general category of the proficiency. */
  type?: string;
  /** Classes that start with this proficiency. */
  classes?: APIReference[];
  /** Races that start with this proficiency. */
  races?: APIReference[];
  /** `APIReference` to the full description of the related resource.
   */
  reference?: APIReference;

  [key: string]: any;
}

/** `Language` */
export interface Language extends APIReference {
  /** Brief description of the language. */
  desc?: string;
  type?: LanguageType;
  /** Script used for writing in the language. */
  script?: string;
  /** List of races that tend to speak the language. */
  typical_speakers?: string[];

  [key: string]: any;
}

/** `Background` */
export interface Background extends APIReference {
  /** Starting proficiencies for all new characters of this background. */
  starting_proficiencies?: APIReference[];
  /** Starting equipment for all new characters of this background. */
  starting_equipment?: APIReference[];
  starting_equipment_options?: Choice;
  language_options?: Choice;
  /** Special feature granted to new characters of this background. */
  feature?: Feature2;
  /** Choice of personality traits for this background. */
  personality_traits?: any;
  ideals?: Choice;
  bonds?: Choice;
  flaws?: Choice;

  [key: string]: any;
}

/** `Feat` */
export interface Feat extends APIReference {
  /** Description of the resource. */
  desc?: string[];
  /** An object of APIReferences to ability scores and minimum scores. */
  prerequisites?: Prerequisite[];

  [key: string]: any;
}

/** `Subclass` */
export interface Subclass extends APIReference {
  /** Description of the resource. */
  desc?: string[];
  class?: APIReference;
  /** Lore-friendly flavor text for a classes respective subclass. */
  subclass_flavor?: string;
  /** Resource url that shows the subclass level progression. */
  subclass_levels?: string;
  spells?: Spells[];

  [key: string]: any;
}

/** `SubclassLevel` */
export interface SubclassLevel {
  /** Resource index for shorthand searching. */
  index?: string;
  /** URL of the referenced resource. */
  url?: string;
  /** Number value for the current level object. */
  level?: number;
  /** Total number of ability score bonuses gained, added from previous levels. */
  ability_score_bonuses?: number;
  /** Proficiency bonus for this class at the specified level. */
  prof_bonus?: number;
  /** List of features gained at this level. */
  features?: APIReference[];
  /** Summary of spells known at this level. */
  spellcasting?: Spellcasting2;
  /** Class specific information such as dice values for bard songs and number of warlock invocations. */
  classspecific?: Classspecific;

  [key: string]: any;
}

export interface SubclassLevelResource {
  index?: string;
  url?: string;
  level?: number;
  features?: APIReference[];
  class?: APIReference;
  subclass?: APIReference;

  [key: string]: any;
}

/** `ClassLevel` */
export interface ClassLevel {
  /** Resource index for shorthand searching. */
  index?: string;
  /** URL of the referenced resource. */
  url?: string;
  /** The number value for the current level object. */
  level?: number;
  /** Total number of ability score bonuses gained, added from previous levels. */
  ability_score_bonuses?: number;
  /** Proficiency bonus for this class at the specified level. */
  prof_bonus?: number;
  /** Features automatically gained at this level. */
  features?: APIReference[];
  /** Summary of spells known at this level. */
  spellcasting?: Spellcasting3;
  /** Class specific information such as dice values for bard songs and number of warlock invocations. */
  class_specific?: Class_specific;

  [key: string]: any;
}

/** `Feature` */
export interface Feature extends APIReference {
  /** Description of the resource. */
  desc?: string[];
  /** The level this feature is gained. */
  level?: number;
  class?: APIReference;
  subclass?: APIReference;
  parent?: APIReference;
  /** The prerequisites for this feature. */
  prerequisites?: Prerequisites[];
  /** Information specific to this feature. */
  feature_specific?: any;

  [key: string]: any;
}

/** `Race` */
export interface Race extends APIReference {
  /** Base move speed for this race (in feet per round). */
  speed?: number;
  /** Racial bonuses to ability scores. */
  ability_bonuses?: AbilityBonus[];
  /** Flavor description of likely alignments this race takes. */
  alignment?: string;
  /** Flavor description of possible ages for this race. */
  age?: string;
  /** Size class of this race. */
  size?: string;
  /** Flavor description of height and weight for this race. */
  size_description?: string;
  /** Starting proficiencies for all new characters of this race. */
  starting_proficiencies?: APIReference[];
  /** Starting proficiency options for all new characters of this race. */
  starting_proficiency_options?: Choice;
  /** Starting languages for all new characters of this race. */
  languages?: APIReference[];
  /** Flavor description of the languages this race knows. */
  language_desc?: string;
  /** Racial traits that provide benefits to its members. */
  traits?: APIReference[];
  /** All possible subraces that this race includes. */
  subraces?: APIReference[];

  [key: string]: any;
}

export interface AbilityBonus {
  /** Bonus amount for this ability score. */
  bonus?: number;
  ability_score?: APIReference;

  [key: string]: any;
}

/** `Spell` */
export interface Spell extends APIReference {
  /** Description of the resource. */
  desc?: string[];
  /** List of descriptions for casting the spell at higher levels. */
  higher_level?: string[];
  /** Range of the spell, usually expressed in feet. */
  range?: string;
  /** List of shorthand for required components of the spell.
V: verbal
S: somatic
M: material
*/
  components?: Components[];
  /** Material component for the spell to be cast. */
  material?: string;
  area_of_effect?: AreaOfEffect;
  /** Determines if a spell can be cast in a 10-min(in-game) ritual. */
  ritual?: boolean;
  /** How long the spell effect lasts. */
  duration?: string;
  /** Determines if a spell needs concentration to persist. */
  concentration?: boolean;
  /** How long it takes for the spell to activate. */
  casting_time?: string;
  /** Level of the spell. */
  level?: number;
  /** Attack type of the spell. */
  attack_type?: string;
  damage?: DamageAtCharacterLevel;
  /** Magic school this spell belongs to. */
  school?: APIReference;
  /** List of classes that are able to learn the spell. */
  classes?: APIReference[];
  /** List of subclasses that have access to the spell. */
  subclasses?: APIReference[];

  [key: string]: any;
}

/** `Subrace` */
export interface Subrace extends APIReference {
  /** Description of the subrace. */
  desc?: string;
  /** Parent race for the subrace. */
  race?: APIReference;
  /** Additional ability bonuses for the subrace. */
  ability_bonuses?: AbilityBonus[];
  /** Starting proficiencies for all new characters of the subrace. */
  starting_proficiencies?: APIReference[];
  /** Starting languages for all new characters of the subrace. */
  languages?: APIReference[];
  /** Starting languages to choose from for the subrace. */
  language_options?: Choice;
  /** List of traits that for the subrace. */
  racial_traits?: APIReference[];

  [key: string]: any;
}

/** `Trait` */
export interface Trait extends APIReference {
  /** Description of the resource. */
  desc?: string[];
  /** List of `Races` that have access to the trait. */
  races?: APIReference[];
  /** List of `Subraces` that have access to the trait. */
  subraces?: APIReference[];
  /** List of `Proficiencies` this trait grants. */
  proficiencies?: APIReference[];
  proficiency_choices?: Choice;
  language_options?: Choice;
  /** Information specific to this trait */
  trait_specific?: Choice;

  [key: string]: any;
}

/** WeaponProperty */
export interface WeaponProperty extends APIReference {
  /** Description of the resource. */
  desc?: string[];

  [key: string]: any;
}

/** `Rule` */
export interface Rule extends APIReference {
  /** Description of the rule. */
  desc?: string;
  /** List of sections for each subheading underneath the rule in the SRD. */
  subsections?: APIReference[];

  [key: string]: any;
}

/** `RuleSection` */
export interface RuleSection extends APIReference {
  /** Description of the rule. */
  desc?: string;

  [key: string]: any;
}

/** `Monster` */
export interface Monster extends APIReference {
  /** Description of the resource. */
  desc?: string[];
  /** A monster's ability to charm or intimidate a player. */
  charisma?: number;
  /** How sturdy a monster is." */
  constitution?: number;
  /** The monster's ability for swift movement or stealth */
  dexterity?: number;
  /** The monster's ability to outsmart a player. */
  intelligence?: number;
  /** How hard a monster can hit a player. */
  strength?: number;
  /** A monster's ability to ascertain the player's plan. */
  wisdom?: number;
  /** The image url of the monster. */
  image?: string;
  /** The size of the monster ranging from Tiny to Gargantuan." */
  size?: MonsterSize;
  /** The type of monster. */
  type?: string;
  /** The sub-category of a monster used for classification of monsters." */
  subtype?: string;
  /** A creature's general moral and personal attitudes. */
  alignment?: MonsterAlignments;
  /** The difficulty for a player to successfully deal damage to a monster. */
  armor_class?: MonsterArmorClass[];
  /** The hit points of a monster determine how much damage it is able to take before it can be defeated. */
  hit_points?: number;
  /** The hit die of a monster can be used to make a version of the same monster whose hit points are determined by the roll of the die. For example: A monster with 2d6 would have its hit points determine by rolling a 6 sided die twice. */
  hit_dice?: string;
  /** The roll for determining a monster's hit points, which consists of the hit dice (e.g. 18d10) and the modifier determined by its Constitution (e.g. +36). For example, 18d10+36 */
  hit_points_roll?: string;
  /** A list of actions that are available to the monster to take during combat. */
  actions?: MonsterAction[];
  /** A list of legendary actions that are available to the monster to take during combat. */
  legendary_actions?: MonsterAction[];
  /** A monster's challenge rating is a guideline number that says when a monster becomes an appropriate challenge against the party's average level. For example. A group of 4 players with an average level of 4 would have an appropriate combat challenge against a monster with a challenge rating of 4 but a monster with a challenge rating of 8 against the same group of players would pose a significant threat. */
  challenge_rating?: number;
  /** A list of conditions that a monster is immune to. */
  condition_immunities?: APIReference[];
  /** A list of damage types that a monster will take double damage from. */
  damage_immunities?: string[];
  /** A list of damage types that a monster will take half damage from. */
  damage_resistances?: string[];
  /** A list of damage types that a monster will take double damage from. */
  damage_vulnerabilities?: string[];
  /** List of other related monster entries that are of the same form. Only applicable to Lycanthropes that have multiple forms. */
  forms?: APIReference[];
  /** The languages a monster is able to speak. */
  languages?: string;
  /** A list of proficiencies of a monster. */
  proficiencies?: MonsterProficiency[];
  /** A list of reactions that is available to the monster to take during combat. */
  reactions?: MonsterAction[];
  /** Monsters typically have a passive perception but they might also have other senses to detect players. */
  senses?: MonsterSense;
  /** A list of the monster's special abilities. */
  special_abilities?: MonsterSpecialAbility[];
  /** Speed for a monster determines how fast it can move per turn. */
  speed?: Speed;
  /** The number of experience points (XP) a monster is worth is based on its challenge rating. */
  xp?: number;

  [key: string]: any;
}

/** `Monster Ability` */
export interface MonsterAbility {
  /** A monster's ability to charm or intimidate a player. */
  charisma?: number;
  /** How sturdy a monster is." */
  constitution?: number;
  /** The monster's ability for swift movement or stealth */
  dexterity?: number;
  /** The monster's ability to outsmart a player. */
  intelligence?: number;
  /** How hard a monster can hit a player. */
  strength?: number;
  /** A monster's ability to ascertain the player's plan. */
  wisdom?: number;

  [key: string]: any;
}

/** Action available to a `Monster` in addition to the standard creature actions. */
export interface MonsterAction {
  name?: string;
  desc?: string;
  action_options?: Choice;
  actions?: MonsterMultiAttackAction[];
  options?: Choice;
  multiattack_type?: string;
  attack_bonus?: number;
  dc?: DC;
  attacks?: MonsterAttack[];
  damage?: Damage[];

  [key: string]: any;
}

/** The armor class of a monster. */
export interface MonsterArmorClass {
  [key: string]: any;
}

export interface MonsterAttack {
  name?: string;
  dc?: DC;
  damage?: Damage;

  [key: string]: any;
}

export interface MonsterMultiAttackAction {
  action_name?: string;
  count?: number;
  type?: MonsterMultiAttackActionType;

  [key: string]: any;
}

export interface MonsterProficiency {
  value?: number;
  proficiency?: APIReference;

  [key: string]: any;
}

export interface MonsterSense {
  /** The monster's passive perception (wisdom) score. */
  passive_perception?: number;
  /** A monster with blindsight can perceive its surroundings without relying on sight, within a specific radius. */
  blindsight?: string;
  /** A monster with darkvision can see in the dark within a specific radius. */
  darkvision?: string;
  /** A monster with tremorsense can detect and pinpoint the origin of vibrations within a specific radius, provided that the monster and the source of the vibrations are in contact with the same ground or substance. */
  tremorsense?: string;
  /** A monster with truesight can, out to a specific range, see in normal and magical darkness, see invisible creatures and objects, automatically detect visual illusions and succeed on saving throws against them, and perceive the original form of a shapechanger or a creature that is transformed by magic. Furthermore, the monster can see into the Ethereal Plane within the same range. */
  truesight?: string;

  [key: string]: any;
}

export interface MonsterSpecialAbility {
  name?: string;
  desc?: string;
  attack_bonus?: number;
  damage?: Damage;
  dc?: DC;
  spellcasting?: MonsterSpellcasting;
  usage?: MonsterUsage;

  [key: string]: any;
}

export interface MonsterSpell {
  name?: string;
  level?: number;
  url?: string;
  usage?: MonsterUsage;

  [key: string]: any;
}

export interface MonsterSpellcasting {
  ability?: APIReference;
  dc?: number;
  modifier?: number;
  components_required?: string[];
  school?: string;
  slots?: { [key: string]: number };
  spells?: MonsterSpell[];

  [key: string]: any;
}

export interface MonsterUsage {
  type?: MonsterUsageType;
  rest_types?: string[];
  times?: number;

  [key: string]: any;
}

/** `SpellPrerequisite` */
export interface SpellPrerequisite extends APIReference {
  /** The type of prerequisite. */
  type?: string;

  [key: string]: any;
}

export interface ErrorResponse {
  error: string;

  [key: string]: any;
}

/** `DC` */
export interface DC {
  dc_type?: APIReference;
  /** Value to beat */
  dc_value?: number;
  /** Result of a successful save. Can be \"none\", \"half\", or \"other\" */
  success_type?: string;

  [key: string]: any;
}

/** `Option Set` */
export interface OptionSet {
  [key: string]: any;
}

/** `Option` */
export interface Option {
  [key: string]: any;
}

export enum Endpoint {
  AbilityScores = 'ability-scores',
  Alignments = 'alignments',
  Backgrounds = 'backgrounds',
  Classes = 'classes',
  Conditions = 'conditions',
  DamageTypes = 'damage-types',
  Equipment = 'equipment',
  EquipmentCategories = 'equipment-categories',
  Feats = 'feats',
  Features = 'features',
  Languages = 'languages',
  MagicItems = 'magic-items',
  MagicSchools = 'magic-schools',
  Monsters = 'monsters',
  Proficiencies = 'proficiencies',
  Races = 'races',
  RuleSections = 'rule-sections',
  Rules = 'rules',
  Skills = 'skills',
  Spells = 'spells',
  Subclasses = 'subclasses',
  Subraces = 'subraces',
  Traits = 'traits',
  WeaponProperties = 'weapon-properties',
}

export enum Index {
  Cha = 'cha',
  Con = 'con',
  Dex = 'dex',
  Int = 'int',
  Str = 'str',
  Wis = 'wis',
}

export enum Index2 {
  ChaoticNeutral = 'chaotic-neutral',
  ChaoticEvil = 'chaotic-evil',
  ChaoticGood = 'chaotic-good',
  LawfulNeutral = 'lawful-neutral',
  LawfulEvil = 'lawful-evil',
  LawfulGood = 'lawful-good',
  Neutral = 'neutral',
  NeutralEvil = 'neutral-evil',
  NeutralGood = 'neutral-good',
}

export enum Index3 {
  Acolyte = 'acolyte',
}

export enum Index4 {
  Barbarian = 'barbarian',
  Bard = 'bard',
  Cleric = 'cleric',
  Druid = 'druid',
  Fighter = 'fighter',
  Monk = 'monk',
  Paladin = 'paladin',
  Ranger = 'ranger',
  Rogue = 'rogue',
  Sorcerer = 'sorcerer',
  Warlock = 'warlock',
  Wizard = 'wizard',
}

export enum Index5 {
  Blinded = 'blinded',
  Charmed = 'charmed',
  Deafened = 'deafened',
  Exhaustion = 'exhaustion',
  Frightened = 'frightened',
  Grappled = 'grappled',
  Incapacitated = 'incapacitated',
  Invisible = 'invisible',
  Paralyzed = 'paralyzed',
  Petrified = 'petrified',
  Poisoned = 'poisoned',
  Prone = 'prone',
  Restrained = 'restrained',
  Stunned = 'stunned',
  Unconscious = 'unconscious',
}

export enum Index6 {
  Acid = 'acid',
  Bludgeoning = 'bludgeoning',
  Cold = 'cold',
  Fire = 'fire',
  Force = 'force',
  Lightning = 'lightning',
  Necrotic = 'necrotic',
  Piercing = 'piercing',
  Poison = 'poison',
  Psychic = 'psychic',
  Radiant = 'radiant',
  Slashing = 'slashing',
  Thunder = 'thunder',
}

export enum Index7 {
  Grappler = 'grappler',
}

export enum Index8 {
  Abyssal = 'abyssal',
  Celestial = 'celestial',
  Common = 'common',
  DeepSpeech = 'deep-speech',
  Draconic = 'draconic',
  Dwarvish = 'dwarvish',
  Elvish = 'elvish',
  Giant = 'giant',
  Gnomish = 'gnomish',
  Goblin = 'goblin',
  Halfling = 'halfling',
  Infernal = 'infernal',
  Orc = 'orc',
  Primordial = 'primordial',
  Sylvan = 'sylvan',
  Undercommon = 'undercommon',
}

export enum Index9 {
  Abjuration = 'abjuration',
  Conjuration = 'conjuration',
  Divination = 'divination',
  Enchantment = 'enchantment',
  Evocation = 'evocation',
  Illusion = 'illusion',
  Necromancy = 'necromancy',
  Transmutation = 'transmutation',
}

export enum Index10 {
  Dragonborn = 'dragonborn',
  Dwarf = 'dwarf',
  Elf = 'elf',
  Gnome = 'gnome',
  HalfElf = 'half-elf',
  HalfOrc = 'half-orc',
  Halfling = 'halfling',
  Human = 'human',
  Tiefling = 'tiefling',
}

export enum Index11 {
  AbilityChecks = 'ability-checks',
  AbilityScoresAndModifiers = 'ability-scores-and-modifiers',
  ActionsInCombat = 'actions-in-combat',
  ActivatingAnItem = 'activating-an-item',
  AdvantageAndDisadvantage = 'advantage-and-disadvantage',
  Attunement = 'attunement',
  BetweenAdventures = 'between-adventures',
  CastingASpell = 'casting-a-spell',
  Cover = 'cover',
  DamageAndHealing = 'damage-and-healing',
  Diseases = 'diseases',
  FantasyHistoricalPantheons = 'fantasy-historical-pantheons',
  Madness = 'madness',
  MakingAnAttack = 'making-an-attack',
  MountedCombat = 'mounted-combat',
  Movement = 'movement',
  MovementAndPosition = 'movement-and-position',
  Objects = 'objects',
  Poisons = 'poisons',
  ProficiencyBonus = 'proficiency-bonus',
  Resting = 'resting',
  SavingThrows = 'saving-throws',
  SentientMagicItems = 'sentient-magic-items',
  StandardExchangeRates = 'standard-exchange-rates',
  TheEnvironment = 'the-environment',
  TheOrderOfCombat = 'the-order-of-combat',
  ThePlanesOfExistence = 'the-planes-of-existence',
  Time = 'time',
  Traps = 'traps',
  UnderwaterCombat = 'underwater-combat',
  UsingEachAbility = 'using-each-ability',
  WearingAndWieldingItems = 'wearing-and-wielding-items',
  WhatIsASpell = 'what-is-a-spell',
}

export enum Index12 {
  Adventuring = 'adventuring',
  Appendix = 'appendix',
  Combat = 'combat',
  Equipment = 'equipment',
  Spellcasting = 'spellcasting',
  UsingAbilityScores = 'using-ability-scores',
}

export enum Index13 {
  Acrobatics = 'acrobatics',
  AnimalHandling = 'animal-handling',
  Arcana = 'arcana',
  Athletics = 'athletics',
  Deception = 'deception',
  History = 'history',
  Insight = 'insight',
  Intimidation = 'intimidation',
  Investigation = 'investigation',
  Medicine = 'medicine',
  Nature = 'nature',
  Perception = 'perception',
  Performance = 'performance',
  Persuasion = 'persuasion',
  Religion = 'religion',
  SleightOfHand = 'sleight-of-hand',
  Stealth = 'stealth',
  Survival = 'survival',
}

export enum Index14 {
  Berserker = 'berserker',
  Champion = 'champion',
  Devotion = 'devotion',
  Draconic = 'draconic',
  Evocation = 'evocation',
  Fiend = 'fiend',
  Hunter = 'hunter',
  Land = 'land',
  Life = 'life',
  Lore = 'lore',
  OpenHand = 'open-hand',
  Thief = 'thief',
}

export enum Index15 {
  HighElf = 'high-elf',
  HillDwarf = 'hill-dwarf',
  LightfootHalfling = 'lightfoot-halfling',
  RockGnome = 'rock-gnome',
}

export enum Index16 {
  ArtificersLore = 'artificers-lore',
  Brave = 'brave',
  BreathWeapon = 'breath-weapon',
  DamageResistance = 'damage-resistance',
  Darkvision = 'darkvision',
  DraconicAncestry = 'draconic-ancestry',
  DraconicAncestryBlack = 'draconic-ancestry-black',
  DraconicAncestryBlue = 'draconic-ancestry-blue',
  DraconicAncestryBrass = 'draconic-ancestry-brass',
  DraconicAncestryBronze = 'draconic-ancestry-bronze',
  DraconicAncestryCopper = 'draconic-ancestry-copper',
  DraconicAncestryGold = 'draconic-ancestry-gold',
  DraconicAncestryGreen = 'draconic-ancestry-green',
  DraconicAncestryRed = 'draconic-ancestry-red',
  DraconicAncestrySilver = 'draconic-ancestry-silver',
  DraconicAncestryWhite = 'draconic-ancestry-white',
  DwarvenCombatTraining = 'dwarven-combat-training',
  DwarvenResilience = 'dwarven-resilience',
  DwarvenToughness = 'dwarven-toughness',
  ElfWeaponTraining = 'elf-weapon-training',
  ExtraLanguage = 'extra-language',
  FeyAncestry = 'fey-ancestry',
  GnomeCunning = 'gnome-cunning',
  HalflingNimbleness = 'halfling-nimbleness',
  HellishResistance = 'hellish-resistance',
  HighElfCantrip = 'high-elf-cantrip',
  InfernalLegacy = 'infernal-legacy',
  KeenSenses = 'keen-senses',
  Lucky = 'lucky',
  Menacing = 'menacing',
  NaturallyStealthy = 'naturally-stealthy',
  RelentlessEndurance = 'relentless-endurance',
  SavageAttacks = 'savage-attacks',
  SkillVersatility = 'skill-versatility',
  Stonecunning = 'stonecunning',
  Tinker = 'tinker',
  ToolProficiency = 'tool-proficiency',
  Trance = 'trance',
}

export enum Index17 {
  Ammunition = 'ammunition',
  Finesse = 'finesse',
  Heavy = 'heavy',
  Light = 'light',
  Loading = 'loading',
  Monk = 'monk',
  Reach = 'reach',
  Special = 'special',
  Thrown = 'thrown',
  TwoHanded = 'two-handed',
  Versatile = 'versatile',
}

export enum AreaOfEffectType {
  Sphere = 'sphere',
  Cone = 'cone',
  Cylinder = 'cylinder',
  Line = 'line',
  Cube = 'cube',
}

export interface Starting_equipment {
  quantity?: number;
  equipment?: APIReference;

  [key: string]: any;
}

export interface Info {
  /** Feature name. */
  name?: string;
  /** Feature description. */
  desc?: string[];

  [key: string]: any;
}

export interface Range {
  /** The weapon's normal range in feet. */
  normal?: number;
  /** The weapon's long range in feet. */
  long?: number;

  [key: string]: any;
}

export interface Rarity {
  /** The rarity of the item. */
  name?: RarityName;

  [key: string]: any;
}

export enum LanguageType {
  Standard = 'Standard',
  Exotic = 'Exotic',
}

export interface Feature2 {
  name?: string;
  desc?: string[];

  [key: string]: any;
}

export interface Spells {
  prerequisites?: SpellPrerequisite[];
  spell?: APIReference;

  [key: string]: any;
}

export interface Spellcasting2 {
  cantrips_known?: number;
  spells_known?: number;
  spell_slots_level_1?: number;
  spell_slots_level_2?: number;
  spell_slots_level_3?: number;
  spell_slots_level_4?: number;
  spell_slots_level_5?: number;
  spell_slots_level_6?: number;
  spell_slots_level_7?: number;
  spell_slots_level_8?: number;
  spell_slots_level_9?: number;

  [key: string]: any;
}

export interface Classspecific {
  [key: string]: any;
}

export interface Spellcasting3 {
  cantrips_known?: number;
  spells_known?: number;
  spell_slots_level_1?: number;
  spell_slots_level_2?: number;
  spell_slots_level_3?: number;
  spell_slots_level_4?: number;
  spell_slots_level_5?: number;
  spell_slots_level_6?: number;
  spell_slots_level_7?: number;
  spell_slots_level_8?: number;
  spell_slots_level_9?: number;

  [key: string]: any;
}

export interface Class_specific {
  [key: string]: any;
}

export interface Prerequisites {
  [key: string]: any;
}

export enum Components {
  V = 'V',
  S = 'S',
  M = 'M',
}

export enum MonsterSize {
  Tiny = 'Tiny',
  Small = 'Small',
  Medium = 'Medium',
  Large = 'Large',
  Huge = 'Huge',
  Gargantuan = 'Gargantuan',
}

export enum MonsterAlignments {
  Chaotic_neutral = 'chaotic neutral',
  Chaotic_evil = 'chaotic evil',
  Chaotic_good = 'chaotic good',
  Lawful_neutral = 'lawful neutral',
  Lawful_evil = 'lawful evil',
  Lawful_good = 'lawful good',
  Neutral = 'neutral',
  Neutral_evil = 'neutral evil',
  Neutral_good = 'neutral good',
  Any_alignment = 'any alignment',
  Unaligned = 'unaligned',
}

export interface Speed {
  /** All creatures have a walking speed, simply called the monster’s speed. Creatures that have no form of ground-based locomotion have a walking speed of 0 feet. */
  walk?: string;
  /** A monster that has a burrowing speed can use that speed to move through sand, earth, mud, or ice. A monster can’t burrow through solid rock unless it has a special trait that allows it to do so. */
  burrow?: string;
  /** A monster that has a climbing speed can use all or part of its movement to move on vertical surfaces. The monster doesn’t need to spend extra movement to climb. */
  climb?: string;
  /** A monster that has a flying speed can use all or part of its movement to fly. */
  fly?: string;
  /** A monster that has a swimming speed doesn’t need to spend extra movement to swim. */
  swim?: string;

  [key: string]: any;
}

export enum MonsterArmorClassType {
  Dex = 'dex',
}

export enum MonsterMultiAttackActionType {
  Melee = 'melee',
  Ranged = 'ranged',
  Ability = 'ability',
  Magic = 'magic',
}

export enum MonsterUsageType {
  At_will = 'at will',
  Per_day = 'per day',
  Recharge_after_rest = 'recharge after rest',
  Recharge_on_roll = 'recharge on roll',
}

export enum RarityName {
  Varies = 'Varies',
  Common = 'Common',
  Uncommon = 'Uncommon',
  Rare = 'Rare',
  Very_Rare = 'Very Rare',
  Legendary = 'Legendary',
  Artifact = 'Artifact',
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any,
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}
