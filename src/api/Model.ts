//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class BuildingsClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : 'http://localhost:5000';
  }

  getBuildingsFromLocale(
    localeId: string,
    page?: number | undefined,
    pageSize?: number | undefined,
    filter?: string | null | undefined,
    orderBy?: string | null | undefined,
    include?: string | null | undefined,
    includeProperties?: string[] | null | undefined,
    expand?: string | null | undefined,
    expandProperties?: string[] | null | undefined,
  ): Promise<Building[]> {
    let url_ = this.baseUrl + '/Buildings/Locale/{localeId}?';
    if (localeId === undefined || localeId === null)
      throw new Error("The parameter 'localeId' must be defined.");
    url_ = url_.replace('{localeId}', encodeURIComponent('' + localeId));
    if (page === null) throw new Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += 'Page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (filter !== undefined && filter !== null)
      url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (orderBy !== undefined && orderBy !== null)
      url_ += 'OrderBy=' + encodeURIComponent('' + orderBy) + '&';
    if (include !== undefined && include !== null)
      url_ += 'Include=' + encodeURIComponent('' + include) + '&';
    if (includeProperties !== undefined && includeProperties !== null)
      includeProperties &&
        includeProperties.forEach((item) => {
          url_ += 'IncludeProperties=' + encodeURIComponent('' + item) + '&';
        });
    if (expand !== undefined && expand !== null)
      url_ += 'Expand=' + encodeURIComponent('' + expand) + '&';
    if (expandProperties !== undefined && expandProperties !== null)
      expandProperties &&
        expandProperties.forEach((item) => {
          url_ += 'ExpandProperties=' + encodeURIComponent('' + item) + '&';
        });
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetBuildingsFromLocale(_response);
    });
  }

  protected processGetBuildingsFromLocale(
    response: Response,
  ): Promise<Building[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Building.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Building[]>(null as any);
  }

  getBuildingById(
    id: string,
    include?: string | null | undefined,
  ): Promise<Building> {
    let url_ = this.baseUrl + '/Buildings/{id}?';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (include !== undefined && include !== null)
      url_ += 'include=' + encodeURIComponent('' + include) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetBuildingById(_response);
    });
  }

  protected processGetBuildingById(response: Response): Promise<Building> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Building.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Building>(null as any);
  }

  patchBuilding(
    id: string,
    patchDoc: JsonPatchDocumentOfBuilding,
    include?: string | null | undefined,
  ): Promise<Building> {
    let url_ = this.baseUrl + '/Buildings/{id}?';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (include !== undefined && include !== null)
      url_ += 'include=' + encodeURIComponent('' + include) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(patchDoc);

    let options_: RequestInit = {
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPatchBuilding(_response);
    });
  }

  protected processPatchBuilding(response: Response): Promise<Building> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Building.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Building>(null as any);
  }

  putBuilding(id: string, building: Building): Promise<FileResponse | null> {
    let url_ = this.baseUrl + '/Buildings/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(building);

    let options_: RequestInit = {
      body: content_,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPutBuilding(_response);
    });
  }

  protected processPutBuilding(
    response: Response,
  ): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition,
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<FileResponse | null>(null as any);
  }

  deleteBuilding(id: string): Promise<Building> {
    let url_ = this.baseUrl + '/Buildings/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeleteBuilding(_response);
    });
  }

  protected processDeleteBuilding(response: Response): Promise<Building> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Building.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Building>(null as any);
  }

  postBuilding(building: Building): Promise<Building> {
    let url_ = this.baseUrl + '/Buildings';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(building);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostBuilding(_response);
    });
  }

  protected processPostBuilding(response: Response): Promise<Building> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Building.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Building>(null as any);
  }

  getEnum(name: string | null): Promise<string[]> {
    let url_ = this.baseUrl + '/Buildings/GetEnum/{name}';
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace('{name}', encodeURIComponent('' + name));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetEnum(_response);
    });
  }

  protected processGetEnum(response: Response): Promise<string[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(item);
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<string[]>(null as any);
  }
}

export class ContinentsClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : 'http://localhost:5000';
  }

  getContinents(
    page?: number | undefined,
    pageSize?: number | undefined,
    filter?: string | null | undefined,
    orderBy?: string | null | undefined,
    include?: string | null | undefined,
    includeProperties?: string[] | null | undefined,
    expand?: string | null | undefined,
    expandProperties?: string[] | null | undefined,
  ): Promise<Continent[]> {
    let url_ = this.baseUrl + '/Continents?';
    if (page === null) throw new Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += 'Page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (filter !== undefined && filter !== null)
      url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (orderBy !== undefined && orderBy !== null)
      url_ += 'OrderBy=' + encodeURIComponent('' + orderBy) + '&';
    if (include !== undefined && include !== null)
      url_ += 'Include=' + encodeURIComponent('' + include) + '&';
    if (includeProperties !== undefined && includeProperties !== null)
      includeProperties &&
        includeProperties.forEach((item) => {
          url_ += 'IncludeProperties=' + encodeURIComponent('' + item) + '&';
        });
    if (expand !== undefined && expand !== null)
      url_ += 'Expand=' + encodeURIComponent('' + expand) + '&';
    if (expandProperties !== undefined && expandProperties !== null)
      expandProperties &&
        expandProperties.forEach((item) => {
          url_ += 'ExpandProperties=' + encodeURIComponent('' + item) + '&';
        });
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetContinents(_response);
    });
  }

  protected processGetContinents(response: Response): Promise<Continent[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Continent.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Continent[]>(null as any);
  }

  postContinent(continent: Continent): Promise<Continent> {
    let url_ = this.baseUrl + '/Continents';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(continent);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostContinent(_response);
    });
  }

  protected processPostContinent(response: Response): Promise<Continent> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Continent.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Continent>(null as any);
  }

  getContinentById(
    id: string,
    include?: string | null | undefined,
  ): Promise<Continent> {
    let url_ = this.baseUrl + '/Continents/{id}?';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (include !== undefined && include !== null)
      url_ += 'include=' + encodeURIComponent('' + include) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetContinentById(_response);
    });
  }

  protected processGetContinentById(response: Response): Promise<Continent> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Continent.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Continent>(null as any);
  }

  patchContinent(
    id: string,
    patchDoc: JsonPatchDocumentOfContinent,
    include?: string | null | undefined,
  ): Promise<Continent> {
    let url_ = this.baseUrl + '/Continents/{id}?';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (include !== undefined && include !== null)
      url_ += 'include=' + encodeURIComponent('' + include) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(patchDoc);

    let options_: RequestInit = {
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPatchContinent(_response);
    });
  }

  protected processPatchContinent(response: Response): Promise<Continent> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Continent.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Continent>(null as any);
  }

  putContinent(id: string, continent: Continent): Promise<FileResponse | null> {
    let url_ = this.baseUrl + '/Continents/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(continent);

    let options_: RequestInit = {
      body: content_,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPutContinent(_response);
    });
  }

  protected processPutContinent(
    response: Response,
  ): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition,
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<FileResponse | null>(null as any);
  }

  deleteContinent(id: string): Promise<Continent> {
    let url_ = this.baseUrl + '/Continents/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeleteContinent(_response);
    });
  }

  protected processDeleteContinent(response: Response): Promise<Continent> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Continent.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Continent>(null as any);
  }

  getEnum(name: string | null): Promise<string[]> {
    let url_ = this.baseUrl + '/Continents/GetEnum/{name}';
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace('{name}', encodeURIComponent('' + name));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetEnum(_response);
    });
  }

  protected processGetEnum(response: Response): Promise<string[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(item);
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<string[]>(null as any);
  }
}

export class LocalesClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : 'http://localhost:5000';
  }

  getLocale(id: string, include?: string | null | undefined): Promise<Locale> {
    let url_ = this.baseUrl + '/Locales/{id}?';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (include !== undefined && include !== null)
      url_ += 'include=' + encodeURIComponent('' + include) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetLocale(_response);
    });
  }

  protected processGetLocale(response: Response): Promise<Locale> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Locale.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Locale>(null as any);
  }

  getRegionsFromContinent(
    regionId: number,
    page?: number | undefined,
    pageSize?: number | undefined,
    filter?: string | null | undefined,
    orderBy?: string | null | undefined,
    include?: string | null | undefined,
    includeProperties?: string[] | null | undefined,
    expand?: string | null | undefined,
    expandProperties?: string[] | null | undefined,
  ): Promise<Locale[]> {
    let url_ = this.baseUrl + '/Locales/Region/{regionId}?';
    if (regionId === undefined || regionId === null)
      throw new Error("The parameter 'regionId' must be defined.");
    url_ = url_.replace('{regionId}', encodeURIComponent('' + regionId));
    if (page === null) throw new Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += 'Page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (filter !== undefined && filter !== null)
      url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (orderBy !== undefined && orderBy !== null)
      url_ += 'OrderBy=' + encodeURIComponent('' + orderBy) + '&';
    if (include !== undefined && include !== null)
      url_ += 'Include=' + encodeURIComponent('' + include) + '&';
    if (includeProperties !== undefined && includeProperties !== null)
      includeProperties &&
        includeProperties.forEach((item) => {
          url_ += 'IncludeProperties=' + encodeURIComponent('' + item) + '&';
        });
    if (expand !== undefined && expand !== null)
      url_ += 'Expand=' + encodeURIComponent('' + expand) + '&';
    if (expandProperties !== undefined && expandProperties !== null)
      expandProperties &&
        expandProperties.forEach((item) => {
          url_ += 'ExpandProperties=' + encodeURIComponent('' + item) + '&';
        });
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetRegionsFromContinent(_response);
    });
  }

  protected processGetRegionsFromContinent(
    response: Response,
  ): Promise<Locale[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(Locale.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Locale[]>(null as any);
  }
}

export class MonstersClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : 'http://localhost:5000';
  }

  getMonsters(
    page?: number | undefined,
    pageSize?: number | undefined,
    filter?: string | null | undefined,
    orderBy?: string | null | undefined,
    include?: string | null | undefined,
    includeProperties?: string[] | null | undefined,
    expand?: string | null | undefined,
    expandProperties?: string[] | null | undefined,
  ): Promise<Monster[]> {
    let url_ = this.baseUrl + '/Monsters?';
    if (page === null) throw new Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += 'Page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (filter !== undefined && filter !== null)
      url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (orderBy !== undefined && orderBy !== null)
      url_ += 'OrderBy=' + encodeURIComponent('' + orderBy) + '&';
    if (include !== undefined && include !== null)
      url_ += 'Include=' + encodeURIComponent('' + include) + '&';
    if (includeProperties !== undefined && includeProperties !== null)
      includeProperties &&
        includeProperties.forEach((item) => {
          url_ += 'IncludeProperties=' + encodeURIComponent('' + item) + '&';
        });
    if (expand !== undefined && expand !== null)
      url_ += 'Expand=' + encodeURIComponent('' + expand) + '&';
    if (expandProperties !== undefined && expandProperties !== null)
      expandProperties &&
        expandProperties.forEach((item) => {
          url_ += 'ExpandProperties=' + encodeURIComponent('' + item) + '&';
        });
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetMonsters(_response);
    });
  }

  protected processGetMonsters(response: Response): Promise<Monster[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(Monster.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Monster[]>(null as any);
  }

  postMonster(monster: Monster): Promise<Monster> {
    let url_ = this.baseUrl + '/Monsters';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(monster);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostMonster(_response);
    });
  }

  protected processPostMonster(response: Response): Promise<Monster> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Monster.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Monster>(null as any);
  }

  getMonsterById(
    id: string,
    include?: string | null | undefined,
  ): Promise<Monster> {
    let url_ = this.baseUrl + '/Monsters/{id}?';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (include !== undefined && include !== null)
      url_ += 'include=' + encodeURIComponent('' + include) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetMonsterById(_response);
    });
  }

  protected processGetMonsterById(response: Response): Promise<Monster> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Monster.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Monster>(null as any);
  }

  patchMonster(
    id: string,
    patchDoc: JsonPatchDocumentOfMonster,
    include?: string | null | undefined,
  ): Promise<Monster> {
    let url_ = this.baseUrl + '/Monsters/{id}?';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (include !== undefined && include !== null)
      url_ += 'include=' + encodeURIComponent('' + include) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(patchDoc);

    let options_: RequestInit = {
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPatchMonster(_response);
    });
  }

  protected processPatchMonster(response: Response): Promise<Monster> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Monster.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Monster>(null as any);
  }

  putMonster(id: string, monster: Monster): Promise<FileResponse | null> {
    let url_ = this.baseUrl + '/Monsters/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(monster);

    let options_: RequestInit = {
      body: content_,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPutMonster(_response);
    });
  }

  protected processPutMonster(
    response: Response,
  ): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition,
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<FileResponse | null>(null as any);
  }

  deleteMonster(id: string): Promise<Monster> {
    let url_ = this.baseUrl + '/Monsters/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeleteMonster(_response);
    });
  }

  protected processDeleteMonster(response: Response): Promise<Monster> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Monster.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Monster>(null as any);
  }

  getEnum(name: string | null): Promise<string[]> {
    let url_ = this.baseUrl + '/Monsters/GetEnum/{name}';
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace('{name}', encodeURIComponent('' + name));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetEnum(_response);
    });
  }

  protected processGetEnum(response: Response): Promise<string[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(item);
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<string[]>(null as any);
  }
}

export class NpcsClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : 'http://localhost:5000';
  }

  getAll(
    page?: number | undefined,
    pageSize?: number | undefined,
    filter?: string | null | undefined,
    orderBy?: string | null | undefined,
    include?: string | null | undefined,
    includeProperties?: string[] | null | undefined,
    expand?: string | null | undefined,
    expandProperties?: string[] | null | undefined,
  ): Promise<Npc[]> {
    let url_ = this.baseUrl + '/Npcs?';
    if (page === null) throw new Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += 'Page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (filter !== undefined && filter !== null)
      url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (orderBy !== undefined && orderBy !== null)
      url_ += 'OrderBy=' + encodeURIComponent('' + orderBy) + '&';
    if (include !== undefined && include !== null)
      url_ += 'Include=' + encodeURIComponent('' + include) + '&';
    if (includeProperties !== undefined && includeProperties !== null)
      includeProperties &&
        includeProperties.forEach((item) => {
          url_ += 'IncludeProperties=' + encodeURIComponent('' + item) + '&';
        });
    if (expand !== undefined && expand !== null)
      url_ += 'Expand=' + encodeURIComponent('' + expand) + '&';
    if (expandProperties !== undefined && expandProperties !== null)
      expandProperties &&
        expandProperties.forEach((item) => {
          url_ += 'ExpandProperties=' + encodeURIComponent('' + item) + '&';
        });
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAll(_response);
    });
  }

  protected processGetAll(response: Response): Promise<Npc[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(Npc.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Npc[]>(null as any);
  }

  get(id: string, include?: string | null | undefined): Promise<Npc> {
    let url_ = this.baseUrl + '/Npcs/{id}?';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (include !== undefined && include !== null)
      url_ += 'include=' + encodeURIComponent('' + include) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGet(_response);
    });
  }

  protected processGet(response: Response): Promise<Npc> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Npc.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Npc>(null as any);
  }

  patch(
    id: string,
    patchDoc: JsonPatchDocumentOfNpc,
    include?: string | null | undefined,
  ): Promise<Npc> {
    let url_ = this.baseUrl + '/Npcs/{id}?';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (include !== undefined && include !== null)
      url_ += 'include=' + encodeURIComponent('' + include) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(patchDoc);

    let options_: RequestInit = {
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPatch(_response);
    });
  }

  protected processPatch(response: Response): Promise<Npc> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Npc.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Npc>(null as any);
  }
}

export class PlayersClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : 'http://localhost:5000';
  }

  getPlayers(): Promise<Player[]> {
    let url_ = this.baseUrl + '/Players';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetPlayers(_response);
    });
  }

  protected processGetPlayers(response: Response): Promise<Player[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(Player.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Player[]>(null as any);
  }

  postPlayer(player: Player): Promise<Player> {
    let url_ = this.baseUrl + '/Players';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(player);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostPlayer(_response);
    });
  }

  protected processPostPlayer(response: Response): Promise<Player> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Player.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Player>(null as any);
  }

  getPlayer(id: string): Promise<Player> {
    let url_ = this.baseUrl + '/Players/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetPlayer(_response);
    });
  }

  protected processGetPlayer(response: Response): Promise<Player> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Player.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Player>(null as any);
  }

  putPlayer(id: string, player: Player): Promise<FileResponse | null> {
    let url_ = this.baseUrl + '/Players/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(player);

    let options_: RequestInit = {
      body: content_,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPutPlayer(_response);
    });
  }

  protected processPutPlayer(response: Response): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition,
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<FileResponse | null>(null as any);
  }

  deletePlayer(id: string): Promise<Player> {
    let url_ = this.baseUrl + '/Players/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeletePlayer(_response);
    });
  }

  protected processDeletePlayer(response: Response): Promise<Player> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Player.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Player>(null as any);
  }
}

export class RegionsClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : 'http://localhost:5000';
  }

  getRegionsFromContinent(
    continentId: string,
    page?: number | undefined,
    pageSize?: number | undefined,
    filter?: string | null | undefined,
    orderBy?: string | null | undefined,
    include?: string | null | undefined,
    includeProperties?: string[] | null | undefined,
    expand?: string | null | undefined,
    expandProperties?: string[] | null | undefined,
  ): Promise<Region[]> {
    let url_ = this.baseUrl + '/Regions/Continent/{continentId}?';
    if (continentId === undefined || continentId === null)
      throw new Error("The parameter 'continentId' must be defined.");
    url_ = url_.replace('{continentId}', encodeURIComponent('' + continentId));
    if (page === null) throw new Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += 'Page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (filter !== undefined && filter !== null)
      url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    if (orderBy !== undefined && orderBy !== null)
      url_ += 'OrderBy=' + encodeURIComponent('' + orderBy) + '&';
    if (include !== undefined && include !== null)
      url_ += 'Include=' + encodeURIComponent('' + include) + '&';
    if (includeProperties !== undefined && includeProperties !== null)
      includeProperties &&
        includeProperties.forEach((item) => {
          url_ += 'IncludeProperties=' + encodeURIComponent('' + item) + '&';
        });
    if (expand !== undefined && expand !== null)
      url_ += 'Expand=' + encodeURIComponent('' + expand) + '&';
    if (expandProperties !== undefined && expandProperties !== null)
      expandProperties &&
        expandProperties.forEach((item) => {
          url_ += 'ExpandProperties=' + encodeURIComponent('' + item) + '&';
        });
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetRegionsFromContinent(_response);
    });
  }

  protected processGetRegionsFromContinent(
    response: Response,
  ): Promise<Region[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(Region.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Region[]>(null as any);
  }

  getRegionById(
    id: string,
    include?: string | null | undefined,
  ): Promise<Region> {
    let url_ = this.baseUrl + '/Regions/{id}?';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (include !== undefined && include !== null)
      url_ += 'include=' + encodeURIComponent('' + include) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetRegionById(_response);
    });
  }

  protected processGetRegionById(response: Response): Promise<Region> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Region.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Region>(null as any);
  }

  patchRegion(
    id: string,
    patchDoc: JsonPatchDocumentOfRegion,
    include?: string | null | undefined,
  ): Promise<Region> {
    let url_ = this.baseUrl + '/Regions/{id}?';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (include !== undefined && include !== null)
      url_ += 'include=' + encodeURIComponent('' + include) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(patchDoc);

    let options_: RequestInit = {
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPatchRegion(_response);
    });
  }

  protected processPatchRegion(response: Response): Promise<Region> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Region.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Region>(null as any);
  }

  putRegion(id: string, region: Region): Promise<FileResponse | null> {
    let url_ = this.baseUrl + '/Regions/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(region);

    let options_: RequestInit = {
      body: content_,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPutRegion(_response);
    });
  }

  protected processPutRegion(response: Response): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition,
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<FileResponse | null>(null as any);
  }

  deleteRegion(id: string): Promise<Region> {
    let url_ = this.baseUrl + '/Regions/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeleteRegion(_response);
    });
  }

  protected processDeleteRegion(response: Response): Promise<Region> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Region.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Region>(null as any);
  }

  postRegion(region: Region): Promise<Region> {
    let url_ = this.baseUrl + '/Regions';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(region);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostRegion(_response);
    });
  }

  protected processPostRegion(response: Response): Promise<Region> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Region.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Region>(null as any);
  }

  getEnum(name: string | null): Promise<string[]> {
    let url_ = this.baseUrl + '/Regions/GetEnum/{name}';
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace('{name}', encodeURIComponent('' + name));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetEnum(_response);
    });
  }

  protected processGetEnum(response: Response): Promise<string[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200) result200!.push(item);
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<string[]>(null as any);
  }
}

export class Base implements IBase {
  id!: string;
  name?: string | undefined;

  constructor(data?: IBase) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): Base {
    data = typeof data === 'object' ? data : {};
    let result = new Base();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface IBase {
  id: string;
  name?: string | undefined;
}

export class Building extends Base implements IBuilding {
  localeId?: string | undefined;
  locale?: Locale | undefined;
  map?: string | undefined;
  npcs?: Npc[] | undefined;
  monsters?: MonsterBuilding[] | undefined;
  players?: Player[] | undefined;
  maps?: BuildingMap[] | undefined;

  constructor(data?: IBuilding) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.localeId = _data['localeId'];
      this.locale = _data['locale']
        ? Locale.fromJS(_data['locale'])
        : <any>undefined;
      this.map = _data['map'];
      if (Array.isArray(_data['npcs'])) {
        this.npcs = [] as any;
        for (let item of _data['npcs']) this.npcs!.push(Npc.fromJS(item));
      }
      if (Array.isArray(_data['monsters'])) {
        this.monsters = [] as any;
        for (let item of _data['monsters'])
          this.monsters!.push(MonsterBuilding.fromJS(item));
      }
      if (Array.isArray(_data['players'])) {
        this.players = [] as any;
        for (let item of _data['players'])
          this.players!.push(Player.fromJS(item));
      }
      if (Array.isArray(_data['maps'])) {
        this.maps = [] as any;
        for (let item of _data['maps'])
          this.maps!.push(BuildingMap.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Building {
    data = typeof data === 'object' ? data : {};
    let result = new Building();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['localeId'] = this.localeId;
    data['locale'] = this.locale ? this.locale.toJSON() : <any>undefined;
    data['map'] = this.map;
    if (Array.isArray(this.npcs)) {
      data['npcs'] = [];
      for (let item of this.npcs) data['npcs'].push(item.toJSON());
    }
    if (Array.isArray(this.monsters)) {
      data['monsters'] = [];
      for (let item of this.monsters) data['monsters'].push(item.toJSON());
    }
    if (Array.isArray(this.players)) {
      data['players'] = [];
      for (let item of this.players) data['players'].push(item.toJSON());
    }
    if (Array.isArray(this.maps)) {
      data['maps'] = [];
      for (let item of this.maps) data['maps'].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface IBuilding extends IBase {
  localeId?: string | undefined;
  locale?: Locale | undefined;
  map?: string | undefined;
  npcs?: Npc[] | undefined;
  monsters?: MonsterBuilding[] | undefined;
  players?: Player[] | undefined;
  maps?: BuildingMap[] | undefined;
}

export class Locale extends Base implements ILocale {
  regionId?: string | undefined;
  region?: Region | undefined;
  buildings?: Building[] | undefined;
  dungeons?: Dungeon[] | undefined;
  players?: Player[] | undefined;
  npcs?: Npc[] | undefined;
  monsters?: MonsterLocale[] | undefined;
  maps?: Map[] | undefined;

  constructor(data?: ILocale) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.regionId = _data['regionId'];
      this.region = _data['region']
        ? Region.fromJS(_data['region'])
        : <any>undefined;
      if (Array.isArray(_data['buildings'])) {
        this.buildings = [] as any;
        for (let item of _data['buildings'])
          this.buildings!.push(Building.fromJS(item));
      }
      if (Array.isArray(_data['dungeons'])) {
        this.dungeons = [] as any;
        for (let item of _data['dungeons'])
          this.dungeons!.push(Dungeon.fromJS(item));
      }
      if (Array.isArray(_data['players'])) {
        this.players = [] as any;
        for (let item of _data['players'])
          this.players!.push(Player.fromJS(item));
      }
      if (Array.isArray(_data['npcs'])) {
        this.npcs = [] as any;
        for (let item of _data['npcs']) this.npcs!.push(Npc.fromJS(item));
      }
      if (Array.isArray(_data['monsters'])) {
        this.monsters = [] as any;
        for (let item of _data['monsters'])
          this.monsters!.push(MonsterLocale.fromJS(item));
      }
      if (Array.isArray(_data['maps'])) {
        this.maps = [] as any;
        for (let item of _data['maps']) this.maps!.push(Map.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Locale {
    data = typeof data === 'object' ? data : {};
    let result = new Locale();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['regionId'] = this.regionId;
    data['region'] = this.region ? this.region.toJSON() : <any>undefined;
    if (Array.isArray(this.buildings)) {
      data['buildings'] = [];
      for (let item of this.buildings) data['buildings'].push(item.toJSON());
    }
    if (Array.isArray(this.dungeons)) {
      data['dungeons'] = [];
      for (let item of this.dungeons) data['dungeons'].push(item.toJSON());
    }
    if (Array.isArray(this.players)) {
      data['players'] = [];
      for (let item of this.players) data['players'].push(item.toJSON());
    }
    if (Array.isArray(this.npcs)) {
      data['npcs'] = [];
      for (let item of this.npcs) data['npcs'].push(item.toJSON());
    }
    if (Array.isArray(this.monsters)) {
      data['monsters'] = [];
      for (let item of this.monsters) data['monsters'].push(item.toJSON());
    }
    if (Array.isArray(this.maps)) {
      data['maps'] = [];
      for (let item of this.maps) data['maps'].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface ILocale extends IBase {
  regionId?: string | undefined;
  region?: Region | undefined;
  buildings?: Building[] | undefined;
  dungeons?: Dungeon[] | undefined;
  players?: Player[] | undefined;
  npcs?: Npc[] | undefined;
  monsters?: MonsterLocale[] | undefined;
  maps?: Map[] | undefined;
}

export class Region extends Base implements IRegion {
  locales?: Locale[] | undefined;
  continentId?: string | undefined;
  continent?: Continent | undefined;
  map?: string | undefined;

  constructor(data?: IRegion) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      if (Array.isArray(_data['locales'])) {
        this.locales = [] as any;
        for (let item of _data['locales'])
          this.locales!.push(Locale.fromJS(item));
      }
      this.continentId = _data['continentId'];
      this.continent = _data['continent']
        ? Continent.fromJS(_data['continent'])
        : <any>undefined;
      this.map = _data['map'];
    }
  }

  static fromJS(data: any): Region {
    data = typeof data === 'object' ? data : {};
    let result = new Region();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.locales)) {
      data['locales'] = [];
      for (let item of this.locales) data['locales'].push(item.toJSON());
    }
    data['continentId'] = this.continentId;
    data['continent'] = this.continent
      ? this.continent.toJSON()
      : <any>undefined;
    data['map'] = this.map;
    super.toJSON(data);
    return data;
  }
}

export interface IRegion extends IBase {
  locales?: Locale[] | undefined;
  continentId?: string | undefined;
  continent?: Continent | undefined;
  map?: string | undefined;
}

export class Continent extends Base implements IContinent {
  regions?: Region[] | undefined;
  map?: string | undefined;

  constructor(data?: IContinent) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      if (Array.isArray(_data['regions'])) {
        this.regions = [] as any;
        for (let item of _data['regions'])
          this.regions!.push(Region.fromJS(item));
      }
      this.map = _data['map'];
    }
  }

  static fromJS(data: any): Continent {
    data = typeof data === 'object' ? data : {};
    let result = new Continent();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.regions)) {
      data['regions'] = [];
      for (let item of this.regions) data['regions'].push(item.toJSON());
    }
    data['map'] = this.map;
    super.toJSON(data);
    return data;
  }
}

export interface IContinent extends IBase {
  regions?: Region[] | undefined;
  map?: string | undefined;
}

export class Dungeon extends Base implements IDungeon {
  type?: string | undefined;
  map?: string | undefined;
  building?: Building | undefined;
  locale?: Locale | undefined;

  constructor(data?: IDungeon) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.type = _data['type'];
      this.map = _data['map'];
      this.building = _data['building']
        ? Building.fromJS(_data['building'])
        : <any>undefined;
      this.locale = _data['locale']
        ? Locale.fromJS(_data['locale'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): Dungeon {
    data = typeof data === 'object' ? data : {};
    let result = new Dungeon();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['type'] = this.type;
    data['map'] = this.map;
    data['building'] = this.building ? this.building.toJSON() : <any>undefined;
    data['locale'] = this.locale ? this.locale.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }
}

export interface IDungeon extends IBase {
  type?: string | undefined;
  map?: string | undefined;
  building?: Building | undefined;
  locale?: Locale | undefined;
}

export class Creature extends Base implements ICreature {
  strength!: number;
  dexterity!: number;
  constitution!: number;
  intelligence!: number;
  wisdom!: number;
  charisma!: number;
  proficiencies?: Proficiencies[] | undefined;
  armorClass!: number;
  hitPoints!: number;
  hitDice?: string | undefined;
  size?: string | undefined;
  speed?: Speed[] | undefined;
  languages?: string | undefined;
  alignment!: Alignment;
  reactions?: CreatureAction[] | undefined;
  picture?: string | undefined;

  constructor(data?: ICreature) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.strength = _data['strength'];
      this.dexterity = _data['dexterity'];
      this.constitution = _data['constitution'];
      this.intelligence = _data['intelligence'];
      this.wisdom = _data['wisdom'];
      this.charisma = _data['charisma'];
      if (Array.isArray(_data['proficiencies'])) {
        this.proficiencies = [] as any;
        for (let item of _data['proficiencies'])
          this.proficiencies!.push(Proficiencies.fromJS(item));
      }
      this.armorClass = _data['armorClass'];
      this.hitPoints = _data['hitPoints'];
      this.hitDice = _data['hitDice'];
      this.size = _data['size'];
      if (Array.isArray(_data['speed'])) {
        this.speed = [] as any;
        for (let item of _data['speed']) this.speed!.push(Speed.fromJS(item));
      }
      this.languages = _data['languages'];
      this.alignment = _data['alignment'];
      if (Array.isArray(_data['reactions'])) {
        this.reactions = [] as any;
        for (let item of _data['reactions'])
          this.reactions!.push(CreatureAction.fromJS(item));
      }
      this.picture = _data['picture'];
    }
  }

  static fromJS(data: any): Creature {
    data = typeof data === 'object' ? data : {};
    let result = new Creature();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['strength'] = this.strength;
    data['dexterity'] = this.dexterity;
    data['constitution'] = this.constitution;
    data['intelligence'] = this.intelligence;
    data['wisdom'] = this.wisdom;
    data['charisma'] = this.charisma;
    if (Array.isArray(this.proficiencies)) {
      data['proficiencies'] = [];
      for (let item of this.proficiencies)
        data['proficiencies'].push(item.toJSON());
    }
    data['armorClass'] = this.armorClass;
    data['hitPoints'] = this.hitPoints;
    data['hitDice'] = this.hitDice;
    data['size'] = this.size;
    if (Array.isArray(this.speed)) {
      data['speed'] = [];
      for (let item of this.speed) data['speed'].push(item.toJSON());
    }
    data['languages'] = this.languages;
    data['alignment'] = this.alignment;
    if (Array.isArray(this.reactions)) {
      data['reactions'] = [];
      for (let item of this.reactions) data['reactions'].push(item.toJSON());
    }
    data['picture'] = this.picture;
    super.toJSON(data);
    return data;
  }
}

export interface ICreature extends IBase {
  strength: number;
  dexterity: number;
  constitution: number;
  intelligence: number;
  wisdom: number;
  charisma: number;
  proficiencies?: Proficiencies[] | undefined;
  armorClass: number;
  hitPoints: number;
  hitDice?: string | undefined;
  size?: string | undefined;
  speed?: Speed[] | undefined;
  languages?: string | undefined;
  alignment: Alignment;
  reactions?: CreatureAction[] | undefined;
  picture?: string | undefined;
}

export class Player extends Creature implements IPlayer {
  level!: number;
  xp!: number;
  inspiration!: boolean;
  playerName?: string | undefined;
  background?: string | undefined;
  faction?: string | undefined;
  race?: string | undefined;
  localeId?: string | undefined;
  locale?: Locale | undefined;
  buildingId?: string | undefined;
  building?: Building | undefined;

  constructor(data?: IPlayer) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.level = _data['level'];
      this.xp = _data['xp'];
      this.inspiration = _data['inspiration'];
      this.playerName = _data['playerName'];
      this.background = _data['background'];
      this.faction = _data['faction'];
      this.race = _data['race'];
      this.localeId = _data['localeId'];
      this.locale = _data['locale']
        ? Locale.fromJS(_data['locale'])
        : <any>undefined;
      this.buildingId = _data['buildingId'];
      this.building = _data['building']
        ? Building.fromJS(_data['building'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): Player {
    data = typeof data === 'object' ? data : {};
    let result = new Player();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['level'] = this.level;
    data['xp'] = this.xp;
    data['inspiration'] = this.inspiration;
    data['playerName'] = this.playerName;
    data['background'] = this.background;
    data['faction'] = this.faction;
    data['race'] = this.race;
    data['localeId'] = this.localeId;
    data['locale'] = this.locale ? this.locale.toJSON() : <any>undefined;
    data['buildingId'] = this.buildingId;
    data['building'] = this.building ? this.building.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }
}

export interface IPlayer extends ICreature {
  level: number;
  xp: number;
  inspiration: boolean;
  playerName?: string | undefined;
  background?: string | undefined;
  faction?: string | undefined;
  race?: string | undefined;
  localeId?: string | undefined;
  locale?: Locale | undefined;
  buildingId?: string | undefined;
  building?: Building | undefined;
}

export class Proficiencies implements IProficiencies {
  name?: string | undefined;
  value!: number;

  constructor(data?: IProficiencies) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): Proficiencies {
    data = typeof data === 'object' ? data : {};
    let result = new Proficiencies();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['value'] = this.value;
    return data;
  }
}

export interface IProficiencies {
  name?: string | undefined;
  value: number;
}

export class Speed implements ISpeed {
  name?: string | undefined;
  value!: number;
  measurement?: string | undefined;

  constructor(data?: ISpeed) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.value = _data['value'];
      this.measurement = _data['measurement'];
    }
  }

  static fromJS(data: any): Speed {
    data = typeof data === 'object' ? data : {};
    let result = new Speed();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['value'] = this.value;
    data['measurement'] = this.measurement;
    return data;
  }
}

export interface ISpeed {
  name?: string | undefined;
  value: number;
  measurement?: string | undefined;
}

export enum Alignment {
  LawfulGood = 0,
  LawfulNeutral = 1,
  LawfulEvil = 2,
  NeutralGood = 3,
  TrueNeutral = 4,
  NeutralEvil = 5,
  ChaoticGood = 6,
  ChaoticNeutral = 7,
  ChaoticEvil = 8,
  Any = 9,
  None = 10,
}

export class CreatureAction implements ICreatureAction {
  name?: string | undefined;
  type?: string | undefined;
  desc?: string | undefined;
  count?: number | undefined;
  attackBonus?: number | undefined;
  damage?: Damage[] | undefined;
  usage?: Usage | undefined;
  actions?: CreatureAction[] | undefined;
  dc?: DC | undefined;

  constructor(data?: ICreatureAction) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.type = _data['type'];
      this.desc = _data['desc'];
      this.count = _data['count'];
      this.attackBonus = _data['attackBonus'];
      if (Array.isArray(_data['damage'])) {
        this.damage = [] as any;
        for (let item of _data['damage'])
          this.damage!.push(Damage.fromJS(item));
      }
      this.usage = _data['usage']
        ? Usage.fromJS(_data['usage'])
        : <any>undefined;
      if (Array.isArray(_data['actions'])) {
        this.actions = [] as any;
        for (let item of _data['actions'])
          this.actions!.push(CreatureAction.fromJS(item));
      }
      this.dc = _data['dc'] ? DC.fromJS(_data['dc']) : <any>undefined;
    }
  }

  static fromJS(data: any): CreatureAction {
    data = typeof data === 'object' ? data : {};
    let result = new CreatureAction();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['type'] = this.type;
    data['desc'] = this.desc;
    data['count'] = this.count;
    data['attackBonus'] = this.attackBonus;
    if (Array.isArray(this.damage)) {
      data['damage'] = [];
      for (let item of this.damage) data['damage'].push(item.toJSON());
    }
    data['usage'] = this.usage ? this.usage.toJSON() : <any>undefined;
    if (Array.isArray(this.actions)) {
      data['actions'] = [];
      for (let item of this.actions) data['actions'].push(item.toJSON());
    }
    data['dc'] = this.dc ? this.dc.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreatureAction {
  name?: string | undefined;
  type?: string | undefined;
  desc?: string | undefined;
  count?: number | undefined;
  attackBonus?: number | undefined;
  damage?: Damage[] | undefined;
  usage?: Usage | undefined;
  actions?: CreatureAction[] | undefined;
  dc?: DC | undefined;
}

export class Damage implements IDamage {
  damageType?: string | undefined;
  damageDice?: string | undefined;
  damageBonus?: number | undefined;

  constructor(data?: IDamage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.damageType = _data['damageType'];
      this.damageDice = _data['damageDice'];
      this.damageBonus = _data['damageBonus'];
    }
  }

  static fromJS(data: any): Damage {
    data = typeof data === 'object' ? data : {};
    let result = new Damage();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['damageType'] = this.damageType;
    data['damageDice'] = this.damageDice;
    data['damageBonus'] = this.damageBonus;
    return data;
  }
}

export interface IDamage {
  damageType?: string | undefined;
  damageDice?: string | undefined;
  damageBonus?: number | undefined;
}

export class Usage implements IUsage {
  type?: string | undefined;
  times?: number | undefined;
  minValue?: number | undefined;

  constructor(data?: IUsage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data['type'];
      this.times = _data['times'];
      this.minValue = _data['minValue'];
    }
  }

  static fromJS(data: any): Usage {
    data = typeof data === 'object' ? data : {};
    let result = new Usage();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['type'] = this.type;
    data['times'] = this.times;
    data['minValue'] = this.minValue;
    return data;
  }
}

export interface IUsage {
  type?: string | undefined;
  times?: number | undefined;
  minValue?: number | undefined;
}

export class DC implements IDC {
  dcType?: string | undefined;
  dcValue!: number;
  successType?: string | undefined;

  constructor(data?: IDC) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.dcType = _data['dcType'];
      this.dcValue = _data['dcValue'];
      this.successType = _data['successType'];
    }
  }

  static fromJS(data: any): DC {
    data = typeof data === 'object' ? data : {};
    let result = new DC();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['dcType'] = this.dcType;
    data['dcValue'] = this.dcValue;
    data['successType'] = this.successType;
    return data;
  }
}

export interface IDC {
  dcType?: string | undefined;
  dcValue: number;
  successType?: string | undefined;
}

export class Npc extends Base implements INpc {
  picture?: string | undefined;
  background?: string | undefined;
  noteableEvents?: any[] | undefined;
  beliefs?: any[] | undefined;
  passions?: any[] | undefined;
  flaws?: any[] | undefined;
  monsterId?: string | undefined;
  monster?: Monster | undefined;
  localeId?: string | undefined;
  locale?: Locale | undefined;
  buildingId?: string | undefined;
  building?: Building | undefined;

  constructor(data?: INpc) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.picture = _data['picture'];
      this.background = _data['background'];
      if (Array.isArray(_data['noteableEvents'])) {
        this.noteableEvents = [] as any;
        for (let item of _data['noteableEvents'])
          this.noteableEvents!.push(item);
      }
      if (Array.isArray(_data['beliefs'])) {
        this.beliefs = [] as any;
        for (let item of _data['beliefs']) this.beliefs!.push(item);
      }
      if (Array.isArray(_data['passions'])) {
        this.passions = [] as any;
        for (let item of _data['passions']) this.passions!.push(item);
      }
      if (Array.isArray(_data['flaws'])) {
        this.flaws = [] as any;
        for (let item of _data['flaws']) this.flaws!.push(item);
      }
      this.monsterId = _data['monsterId'];
      this.monster = _data['monster']
        ? Monster.fromJS(_data['monster'])
        : <any>undefined;
      this.localeId = _data['localeId'];
      this.locale = _data['locale']
        ? Locale.fromJS(_data['locale'])
        : <any>undefined;
      this.buildingId = _data['buildingId'];
      this.building = _data['building']
        ? Building.fromJS(_data['building'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): Npc {
    data = typeof data === 'object' ? data : {};
    let result = new Npc();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['picture'] = this.picture;
    data['background'] = this.background;
    if (Array.isArray(this.noteableEvents)) {
      data['noteableEvents'] = [];
      for (let item of this.noteableEvents) data['noteableEvents'].push(item);
    }
    if (Array.isArray(this.beliefs)) {
      data['beliefs'] = [];
      for (let item of this.beliefs) data['beliefs'].push(item);
    }
    if (Array.isArray(this.passions)) {
      data['passions'] = [];
      for (let item of this.passions) data['passions'].push(item);
    }
    if (Array.isArray(this.flaws)) {
      data['flaws'] = [];
      for (let item of this.flaws) data['flaws'].push(item);
    }
    data['monsterId'] = this.monsterId;
    data['monster'] = this.monster ? this.monster.toJSON() : <any>undefined;
    data['localeId'] = this.localeId;
    data['locale'] = this.locale ? this.locale.toJSON() : <any>undefined;
    data['buildingId'] = this.buildingId;
    data['building'] = this.building ? this.building.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }
}

export interface INpc extends IBase {
  picture?: string | undefined;
  background?: string | undefined;
  noteableEvents?: any[] | undefined;
  beliefs?: any[] | undefined;
  passions?: any[] | undefined;
  flaws?: any[] | undefined;
  monsterId?: string | undefined;
  monster?: Monster | undefined;
  localeId?: string | undefined;
  locale?: Locale | undefined;
  buildingId?: string | undefined;
  building?: Building | undefined;
}

export class Monster extends Creature implements IMonster {
  challengeRating!: number;
  xp!: number;
  passivePerception!: number;
  monsterType!: MonsterType;
  actions?: CreatureAction[] | undefined;
  legendaryActions?: CreatureAction[] | undefined;
  specialAbilities?: CreatureAction[] | undefined;
  senses?: { [key: string]: string } | undefined;
  npcs?: Npc[] | undefined;
  locales?: MonsterLocale[] | undefined;
  buildings?: MonsterBuilding[] | undefined;

  constructor(data?: IMonster) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.challengeRating = _data['challengeRating'];
      this.xp = _data['xp'];
      this.passivePerception = _data['passivePerception'];
      this.monsterType = _data['monsterType'];
      if (Array.isArray(_data['actions'])) {
        this.actions = [] as any;
        for (let item of _data['actions'])
          this.actions!.push(CreatureAction.fromJS(item));
      }
      if (Array.isArray(_data['legendaryActions'])) {
        this.legendaryActions = [] as any;
        for (let item of _data['legendaryActions'])
          this.legendaryActions!.push(CreatureAction.fromJS(item));
      }
      if (Array.isArray(_data['specialAbilities'])) {
        this.specialAbilities = [] as any;
        for (let item of _data['specialAbilities'])
          this.specialAbilities!.push(CreatureAction.fromJS(item));
      }
      if (_data['senses']) {
        this.senses = {} as any;
        for (let key in _data['senses']) {
          if (_data['senses'].hasOwnProperty(key))
            (<any>this.senses)![key] = _data['senses'][key];
        }
      }
      if (Array.isArray(_data['npcs'])) {
        this.npcs = [] as any;
        for (let item of _data['npcs']) this.npcs!.push(Npc.fromJS(item));
      }
      if (Array.isArray(_data['locales'])) {
        this.locales = [] as any;
        for (let item of _data['locales'])
          this.locales!.push(MonsterLocale.fromJS(item));
      }
      if (Array.isArray(_data['buildings'])) {
        this.buildings = [] as any;
        for (let item of _data['buildings'])
          this.buildings!.push(MonsterBuilding.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Monster {
    data = typeof data === 'object' ? data : {};
    let result = new Monster();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['challengeRating'] = this.challengeRating;
    data['xp'] = this.xp;
    data['passivePerception'] = this.passivePerception;
    data['monsterType'] = this.monsterType;
    if (Array.isArray(this.actions)) {
      data['actions'] = [];
      for (let item of this.actions) data['actions'].push(item.toJSON());
    }
    if (Array.isArray(this.legendaryActions)) {
      data['legendaryActions'] = [];
      for (let item of this.legendaryActions)
        data['legendaryActions'].push(item.toJSON());
    }
    if (Array.isArray(this.specialAbilities)) {
      data['specialAbilities'] = [];
      for (let item of this.specialAbilities)
        data['specialAbilities'].push(item.toJSON());
    }
    if (this.senses) {
      data['senses'] = {};
      for (let key in this.senses) {
        if (this.senses.hasOwnProperty(key))
          (<any>data['senses'])[key] = (<any>this.senses)[key];
      }
    }
    if (Array.isArray(this.npcs)) {
      data['npcs'] = [];
      for (let item of this.npcs) data['npcs'].push(item.toJSON());
    }
    if (Array.isArray(this.locales)) {
      data['locales'] = [];
      for (let item of this.locales) data['locales'].push(item.toJSON());
    }
    if (Array.isArray(this.buildings)) {
      data['buildings'] = [];
      for (let item of this.buildings) data['buildings'].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface IMonster extends ICreature {
  challengeRating: number;
  xp: number;
  passivePerception: number;
  monsterType: MonsterType;
  actions?: CreatureAction[] | undefined;
  legendaryActions?: CreatureAction[] | undefined;
  specialAbilities?: CreatureAction[] | undefined;
  senses?: { [key: string]: string } | undefined;
  npcs?: Npc[] | undefined;
  locales?: MonsterLocale[] | undefined;
  buildings?: MonsterBuilding[] | undefined;
}

export enum MonsterType {
  Abberation = 0,
  Beast = 1,
  Celestial = 2,
  Construct = 3,
  Dragon = 4,
  Elemental = 5,
  Fey = 6,
  Fiend = 7,
  Giant = 8,
  Humanoid = 9,
  Monstrosity = 10,
  Ooze = 11,
  Plant = 12,
  Undead = 13,
  None = 14,
}

export class MonsterLocale implements IMonsterLocale {
  monsterId!: string;
  monster?: Monster | undefined;
  localeId!: string;
  locale?: Locale | undefined;

  constructor(data?: IMonsterLocale) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.monsterId = _data['monsterId'];
      this.monster = _data['monster']
        ? Monster.fromJS(_data['monster'])
        : <any>undefined;
      this.localeId = _data['localeId'];
      this.locale = _data['locale']
        ? Locale.fromJS(_data['locale'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): MonsterLocale {
    data = typeof data === 'object' ? data : {};
    let result = new MonsterLocale();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['monsterId'] = this.monsterId;
    data['monster'] = this.monster ? this.monster.toJSON() : <any>undefined;
    data['localeId'] = this.localeId;
    data['locale'] = this.locale ? this.locale.toJSON() : <any>undefined;
    return data;
  }
}

export interface IMonsterLocale {
  monsterId: string;
  monster?: Monster | undefined;
  localeId: string;
  locale?: Locale | undefined;
}

export class MonsterBuilding implements IMonsterBuilding {
  monsterId!: string;
  monster?: Monster | undefined;
  buildingId!: string;
  building?: Building | undefined;

  constructor(data?: IMonsterBuilding) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.monsterId = _data['monsterId'];
      this.monster = _data['monster']
        ? Monster.fromJS(_data['monster'])
        : <any>undefined;
      this.buildingId = _data['buildingId'];
      this.building = _data['building']
        ? Building.fromJS(_data['building'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): MonsterBuilding {
    data = typeof data === 'object' ? data : {};
    let result = new MonsterBuilding();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['monsterId'] = this.monsterId;
    data['monster'] = this.monster ? this.monster.toJSON() : <any>undefined;
    data['buildingId'] = this.buildingId;
    data['building'] = this.building ? this.building.toJSON() : <any>undefined;
    return data;
  }
}

export interface IMonsterBuilding {
  monsterId: string;
  monster?: Monster | undefined;
  buildingId: string;
  building?: Building | undefined;
}

export class Map extends Base implements IMap {
  variation?: string | undefined;
  imageUrl?: string | undefined;
  center?: any[] | undefined;
  localeId!: string;
  locale?: Locale | undefined;
  buildings?: BuildingMap[] | undefined;

  constructor(data?: IMap) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.variation = _data['variation'];
      this.imageUrl = _data['imageUrl'];
      if (Array.isArray(_data['center'])) {
        this.center = [] as any;
        for (let item of _data['center']) this.center!.push(item);
      }
      this.localeId = _data['localeId'];
      this.locale = _data['locale']
        ? Locale.fromJS(_data['locale'])
        : <any>undefined;
      if (Array.isArray(_data['buildings'])) {
        this.buildings = [] as any;
        for (let item of _data['buildings'])
          this.buildings!.push(BuildingMap.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Map {
    data = typeof data === 'object' ? data : {};
    let result = new Map();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['variation'] = this.variation;
    data['imageUrl'] = this.imageUrl;
    if (Array.isArray(this.center)) {
      data['center'] = [];
      for (let item of this.center) data['center'].push(item);
    }
    data['localeId'] = this.localeId;
    data['locale'] = this.locale ? this.locale.toJSON() : <any>undefined;
    if (Array.isArray(this.buildings)) {
      data['buildings'] = [];
      for (let item of this.buildings) data['buildings'].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface IMap extends IBase {
  variation?: string | undefined;
  imageUrl?: string | undefined;
  center?: any[] | undefined;
  localeId: string;
  locale?: Locale | undefined;
  buildings?: BuildingMap[] | undefined;
}

export class BuildingMap implements IBuildingMap {
  buildingId!: string;
  building?: Building | undefined;
  mapId!: string;
  map?: Map | undefined;
  coords?: any[] | undefined;

  constructor(data?: IBuildingMap) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.buildingId = _data['buildingId'];
      this.building = _data['building']
        ? Building.fromJS(_data['building'])
        : <any>undefined;
      this.mapId = _data['mapId'];
      this.map = _data['map'] ? Map.fromJS(_data['map']) : <any>undefined;
      if (Array.isArray(_data['coords'])) {
        this.coords = [] as any;
        for (let item of _data['coords']) this.coords!.push(item);
      }
    }
  }

  static fromJS(data: any): BuildingMap {
    data = typeof data === 'object' ? data : {};
    let result = new BuildingMap();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['buildingId'] = this.buildingId;
    data['building'] = this.building ? this.building.toJSON() : <any>undefined;
    data['mapId'] = this.mapId;
    data['map'] = this.map ? this.map.toJSON() : <any>undefined;
    if (Array.isArray(this.coords)) {
      data['coords'] = [];
      for (let item of this.coords) data['coords'].push(item);
    }
    return data;
  }
}

export interface IBuildingMap {
  buildingId: string;
  building?: Building | undefined;
  mapId: string;
  map?: Map | undefined;
  coords?: any[] | undefined;
}

export class JsonPatchDocumentOfBuilding
  implements IJsonPatchDocumentOfBuilding
{
  operations?: OperationOfBuilding[] | undefined;
  contractResolver?: IContractResolver | undefined;

  constructor(data?: IJsonPatchDocumentOfBuilding) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['operations'])) {
        this.operations = [] as any;
        for (let item of _data['operations'])
          this.operations!.push(OperationOfBuilding.fromJS(item));
      }
      this.contractResolver = _data['contractResolver']
        ? IContractResolver.fromJS(_data['contractResolver'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): JsonPatchDocumentOfBuilding {
    data = typeof data === 'object' ? data : {};
    let result = new JsonPatchDocumentOfBuilding();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.operations)) {
      data['operations'] = [];
      for (let item of this.operations) data['operations'].push(item.toJSON());
    }
    data['contractResolver'] = this.contractResolver
      ? this.contractResolver.toJSON()
      : <any>undefined;
    return data;
  }
}

export interface IJsonPatchDocumentOfBuilding {
  operations?: OperationOfBuilding[] | undefined;
  contractResolver?: IContractResolver | undefined;
}

export class OperationBase implements IOperationBase {
  operationType!: OperationType;
  path?: string | undefined;
  op?: string | undefined;
  from?: string | undefined;

  constructor(data?: IOperationBase) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.operationType = _data['operationType'];
      this.path = _data['path'];
      this.op = _data['op'];
      this.from = _data['from'];
    }
  }

  static fromJS(data: any): OperationBase {
    data = typeof data === 'object' ? data : {};
    let result = new OperationBase();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['operationType'] = this.operationType;
    data['path'] = this.path;
    data['op'] = this.op;
    data['from'] = this.from;
    return data;
  }
}

export interface IOperationBase {
  operationType: OperationType;
  path?: string | undefined;
  op?: string | undefined;
  from?: string | undefined;
}

export class Operation extends OperationBase implements IOperation {
  value?: any | undefined;

  constructor(data?: IOperation) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): Operation {
    data = typeof data === 'object' ? data : {};
    let result = new Operation();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value;
    super.toJSON(data);
    return data;
  }
}

export interface IOperation extends IOperationBase {
  value?: any | undefined;
}

export class OperationOfBuilding
  extends Operation
  implements IOperationOfBuilding
{
  constructor(data?: IOperationOfBuilding) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): OperationOfBuilding {
    data = typeof data === 'object' ? data : {};
    let result = new OperationOfBuilding();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IOperationOfBuilding extends IOperation {}

export enum OperationType {
  Add = 0,
  Remove = 1,
  Replace = 2,
  Move = 3,
  Copy = 4,
  Test = 5,
  Invalid = 6,
}

export abstract class IContractResolver implements IIContractResolver {
  constructor(data?: IIContractResolver) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): IContractResolver {
    data = typeof data === 'object' ? data : {};
    throw new Error(
      "The abstract class 'IContractResolver' cannot be instantiated.",
    );
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    return data;
  }
}

export interface IIContractResolver {}

export class JsonPatchDocumentOfContinent
  implements IJsonPatchDocumentOfContinent
{
  operations?: OperationOfContinent[] | undefined;
  contractResolver?: IContractResolver | undefined;

  constructor(data?: IJsonPatchDocumentOfContinent) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['operations'])) {
        this.operations = [] as any;
        for (let item of _data['operations'])
          this.operations!.push(OperationOfContinent.fromJS(item));
      }
      this.contractResolver = _data['contractResolver']
        ? IContractResolver.fromJS(_data['contractResolver'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): JsonPatchDocumentOfContinent {
    data = typeof data === 'object' ? data : {};
    let result = new JsonPatchDocumentOfContinent();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.operations)) {
      data['operations'] = [];
      for (let item of this.operations) data['operations'].push(item.toJSON());
    }
    data['contractResolver'] = this.contractResolver
      ? this.contractResolver.toJSON()
      : <any>undefined;
    return data;
  }
}

export interface IJsonPatchDocumentOfContinent {
  operations?: OperationOfContinent[] | undefined;
  contractResolver?: IContractResolver | undefined;
}

export class OperationOfContinent
  extends Operation
  implements IOperationOfContinent
{
  constructor(data?: IOperationOfContinent) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): OperationOfContinent {
    data = typeof data === 'object' ? data : {};
    let result = new OperationOfContinent();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IOperationOfContinent extends IOperation {}

export class JsonPatchDocumentOfMonster implements IJsonPatchDocumentOfMonster {
  operations?: OperationOfMonster[] | undefined;
  contractResolver?: IContractResolver | undefined;

  constructor(data?: IJsonPatchDocumentOfMonster) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['operations'])) {
        this.operations = [] as any;
        for (let item of _data['operations'])
          this.operations!.push(OperationOfMonster.fromJS(item));
      }
      this.contractResolver = _data['contractResolver']
        ? IContractResolver.fromJS(_data['contractResolver'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): JsonPatchDocumentOfMonster {
    data = typeof data === 'object' ? data : {};
    let result = new JsonPatchDocumentOfMonster();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.operations)) {
      data['operations'] = [];
      for (let item of this.operations) data['operations'].push(item.toJSON());
    }
    data['contractResolver'] = this.contractResolver
      ? this.contractResolver.toJSON()
      : <any>undefined;
    return data;
  }
}

export interface IJsonPatchDocumentOfMonster {
  operations?: OperationOfMonster[] | undefined;
  contractResolver?: IContractResolver | undefined;
}

export class OperationOfMonster
  extends Operation
  implements IOperationOfMonster
{
  constructor(data?: IOperationOfMonster) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): OperationOfMonster {
    data = typeof data === 'object' ? data : {};
    let result = new OperationOfMonster();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IOperationOfMonster extends IOperation {}

export class JsonPatchDocumentOfNpc implements IJsonPatchDocumentOfNpc {
  operations?: OperationOfNpc[] | undefined;
  contractResolver?: IContractResolver | undefined;

  constructor(data?: IJsonPatchDocumentOfNpc) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['operations'])) {
        this.operations = [] as any;
        for (let item of _data['operations'])
          this.operations!.push(OperationOfNpc.fromJS(item));
      }
      this.contractResolver = _data['contractResolver']
        ? IContractResolver.fromJS(_data['contractResolver'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): JsonPatchDocumentOfNpc {
    data = typeof data === 'object' ? data : {};
    let result = new JsonPatchDocumentOfNpc();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.operations)) {
      data['operations'] = [];
      for (let item of this.operations) data['operations'].push(item.toJSON());
    }
    data['contractResolver'] = this.contractResolver
      ? this.contractResolver.toJSON()
      : <any>undefined;
    return data;
  }
}

export interface IJsonPatchDocumentOfNpc {
  operations?: OperationOfNpc[] | undefined;
  contractResolver?: IContractResolver | undefined;
}

export class OperationOfNpc extends Operation implements IOperationOfNpc {
  constructor(data?: IOperationOfNpc) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): OperationOfNpc {
    data = typeof data === 'object' ? data : {};
    let result = new OperationOfNpc();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IOperationOfNpc extends IOperation {}

export class JsonPatchDocumentOfRegion implements IJsonPatchDocumentOfRegion {
  operations?: OperationOfRegion[] | undefined;
  contractResolver?: IContractResolver | undefined;

  constructor(data?: IJsonPatchDocumentOfRegion) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['operations'])) {
        this.operations = [] as any;
        for (let item of _data['operations'])
          this.operations!.push(OperationOfRegion.fromJS(item));
      }
      this.contractResolver = _data['contractResolver']
        ? IContractResolver.fromJS(_data['contractResolver'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): JsonPatchDocumentOfRegion {
    data = typeof data === 'object' ? data : {};
    let result = new JsonPatchDocumentOfRegion();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.operations)) {
      data['operations'] = [];
      for (let item of this.operations) data['operations'].push(item.toJSON());
    }
    data['contractResolver'] = this.contractResolver
      ? this.contractResolver.toJSON()
      : <any>undefined;
    return data;
  }
}

export interface IJsonPatchDocumentOfRegion {
  operations?: OperationOfRegion[] | undefined;
  contractResolver?: IContractResolver | undefined;
}

export class OperationOfRegion extends Operation implements IOperationOfRegion {
  constructor(data?: IOperationOfRegion) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
  }

  static fromJS(data: any): OperationOfRegion {
    data = typeof data === 'object' ? data : {};
    let result = new OperationOfRegion();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IOperationOfRegion extends IOperation {}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any,
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}
